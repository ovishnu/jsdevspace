(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.minim = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var negate = require('lodash/negate');

// Coerces an a parameter into a callback for matching elements.
// This accepts an element name, an element type and returns a
// callback to match for those elements.
function coerceElementMatchingCallback(value) {
  // Element Name
  if (typeof value === 'string') {
    return function (element) {
      return element.element === value;
    };
  }

  // Element Type
  if (value.constructor && value.extend) {
    return function (element) {
      return element instanceof value;
    };
  }

  return value;
}

/**
 * @class
 *
 * @param {Element[]} elements
 *
 * @property {Element[]} elements
 */

var ArraySlice = function () {
  function ArraySlice(elements) {
    _classCallCheck(this, ArraySlice);

    this.elements = elements || [];
  }

  /**
   * @returns {Array}
   */

  _createClass(ArraySlice, [{
    key: 'toValue',
    value: function toValue() {
      return this.elements.map(function (element) {
        return element.toValue();
      });
    }

    // High Order Functions

    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {array} A new array with each element being the result of the callback function
     */

  }, {
    key: 'map',
    value: function map(callback, thisArg) {
      return this.elements.map(callback, thisArg);
    }

    /**
     * Maps and then flattens the results.
     * @param callback - Function to execute for each element.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {array}
     */

  }, {
    key: 'flatMap',
    value: function flatMap(callback, thisArg) {
      return this.map(callback, thisArg).reduce(function (a, b) {
        return a.concat(b);
      }, []);
    }

    /**
     * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
     * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArraySlice.prototype
     * @returns An array of the non-undefined results of calling transform with each element of the array
     */

  }, {
    key: 'compactMap',
    value: function compactMap(transform, thisArg) {
      var results = [];

      this.forEach(function (element) {
        var result = transform.bind(thisArg)(element);

        if (result) {
          results.push(result);
        }
      });

      return results;
    }

    /**
     * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'filter',
    value: function filter(callback, thisArg) {
      callback = coerceElementMatchingCallback(callback);
      return new ArraySlice(this.elements.filter(callback, thisArg));
    }

    /**
     * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'reject',
    value: function reject(callback, thisArg) {
      callback = coerceElementMatchingCallback(callback);
      return new ArraySlice(this.elements.filter(negate(callback), thisArg));
    }

    /**
     * Returns the first element in the array that satisfies the given value
     * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {Element}
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'find',
    value: function find(callback, thisArg) {
      callback = coerceElementMatchingCallback(callback);
      return this.elements.find(callback, thisArg);
    }

    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      this.elements.forEach(callback, thisArg);
    }

    /**
     * @param callback - Function to execute for each element
     * @param initialValue
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'reduce',
    value: function reduce(callback, initialValue) {
      return this.elements.reduce(callback, initialValue);
    }

    /**
     * @param value
     * @returns {boolean}
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'includes',
    value: function includes(value) {
      return this.elements.some(function (element) {
        return element.equals(value);
      });
    }

    // Mutation

    /**
     * Removes the first element from the slice
     * @returns {Element} The removed element or undefined if the slice is empty
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'shift',
    value: function shift() {
      return this.elements.shift();
    }

    /**
     * Adds the given element to the begining of the slice
     * @parameter {Element} value
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'unshift',
    value: function unshift(value) {
      this.elements.unshift(this.refract(value));
    }

    /**
     * Adds the given element to the end of the slice
     * @parameter {Element} value
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'push',
    value: function push(value) {
      this.elements.push(this.refract(value));
      return this;
    }

    /**
     * @parameter {Element} value
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'add',
    value: function add(value) {
      this.push(value);
    }

    // Accessors

    /**
     * @parameter {number} index
     * @returns {Element}
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'get',
    value: function get(index) {
      return this.elements[index];
    }

    /**
     * @parameter {number} index
     * @memberof ArraySlice.prototype
     */

  }, {
    key: 'getValue',
    value: function getValue(index) {
      var element = this.elements[index];

      if (element) {
        return element.toValue();
      }

      return undefined;
    }

    /**
     * Returns the number of elements in the slice
     * @type number
     */

  }, {
    key: 'length',
    get: function get() {
      return this.elements.length;
    }

    /**
     * Returns whether the slice is empty
     * @type boolean
     */

  }, {
    key: 'isEmpty',
    get: function get() {
      return this.elements.length === 0;
    }

    /**
     * Returns the first element in the slice or undefined if the slice is empty
     * @type Element
     */

  }, {
    key: 'first',
    get: function get() {
      return this.elements[0];
    }
  }]);

  return ArraySlice;
}();

if (typeof Symbol !== 'undefined') {
  ArraySlice.prototype[Symbol.iterator] = function symbol() {
    return this.elements[Symbol.iterator]();
  };
}

module.exports = ArraySlice;

},{"lodash/negate":110}],2:[function(require,module,exports){
"use strict";

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @class
 *
 * @property {Element} key
 * @property {Element} value
 */
var KeyValuePair = function () {
  function KeyValuePair(key, value) {
    _classCallCheck(this, KeyValuePair);

    this.key = key;
    this.value = value;
  }

  /**
   * @returns {KeyValuePair}
   */

  _createClass(KeyValuePair, [{
    key: "clone",
    value: function clone() {
      var clone = new KeyValuePair();

      if (this.key) {
        clone.key = this.key.clone();
      }

      if (this.value) {
        clone.value = this.value.clone();
      }

      return clone;
    }
  }]);

  return KeyValuePair;
}();

module.exports = KeyValuePair;

},{}],3:[function(require,module,exports){
'use strict';

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var isNull = require('lodash/isNull');
var isString = require('lodash/isString');
var isNumber = require('lodash/isNumber');
var isBoolean = require('lodash/isBoolean');
var isObject = require('lodash/isObject');

var JSONSerialiser = require('./serialisers/JSONSerialiser');
var elements = require('./elements');

/**
 * @class
 *
 * A refract element implementation with an extensible namespace, able to
 * load other namespaces into it.
 *
 * The namespace allows you to register your own classes to be instantiated
 * when a particular refract element is encountered, and allows you to specify
 * which elements get instantiated for existing Javascript objects.
 */

var Namespace = function () {
  function Namespace(options) {
    _classCallCheck(this, Namespace);

    this.elementMap = {};
    this.elementDetection = [];
    this.Element = elements.Element;
    this.KeyValuePair = elements.KeyValuePair;

    if (!options || !options.noDefault) {
      this.useDefault();
    }

    // These provide the defaults for new elements.
    this._attributeElementKeys = [];
    this._attributeElementArrayKeys = [];
  }

  /**
   * Use a namespace plugin or load a generic plugin.
   *
   * @param plugin
   */

  _createClass(Namespace, [{
    key: 'use',
    value: function use(plugin) {
      if (plugin.namespace) {
        plugin.namespace({ base: this });
      }
      if (plugin.load) {
        plugin.load({ base: this });
      }
      return this;
    }

    /*
     * Use the default namespace. This preloads all the default elements
     * into this registry instance.
     */

  }, {
    key: 'useDefault',
    value: function useDefault() {
      // Set up classes for default elements
      this.register('null', elements.NullElement).register('string', elements.StringElement).register('number', elements.NumberElement).register('boolean', elements.BooleanElement).register('array', elements.ArrayElement).register('object', elements.ObjectElement).register('member', elements.MemberElement).register('ref', elements.RefElement).register('link', elements.LinkElement);

      // Add instance detection functions to convert existing objects into
      // the corresponding refract elements.
      this.detect(isNull, elements.NullElement, false).detect(isString, elements.StringElement, false).detect(isNumber, elements.NumberElement, false).detect(isBoolean, elements.BooleanElement, false).detect(Array.isArray, elements.ArrayElement, false).detect(isObject, elements.ObjectElement, false);

      return this;
    }

    /**
     * Register a new element class for an element.
     *
     * @param {string} name
     * @param elementClass
     */

  }, {
    key: 'register',
    value: function register(name, ElementClass) {
      this._elements = undefined;
      this.elementMap[name] = ElementClass;
      return this;
    }

    /**
     * Unregister a previously registered class for an element.
     *
     * @param {string} name
     */

  }, {
    key: 'unregister',
    value: function unregister(name) {
      this._elements = undefined;
      delete this.elementMap[name];
      return this;
    }

    /*
     * Add a new detection function to determine which element
     * class to use when converting existing js instances into
     * refract element.
     */

  }, {
    key: 'detect',
    value: function detect(test, ElementClass, givenPrepend) {
      var prepend = givenPrepend === undefined ? true : givenPrepend;

      if (prepend) {
        this.elementDetection.unshift([test, ElementClass]);
      } else {
        this.elementDetection.push([test, ElementClass]);
      }

      return this;
    }

    /*
     * Convert an existing Javascript object into refract element instances, which
     * can be further processed or serialized into refract.
     * If the item passed in is already refracted, then it is returned
     * unmodified.
     */

  }, {
    key: 'toElement',
    value: function toElement(value) {
      if (value instanceof this.Element) {
        return value;
      }

      var element = void 0;

      for (var i = 0; i < this.elementDetection.length; i += 1) {
        var test = this.elementDetection[i][0];
        var ElementClass = this.elementDetection[i][1];

        if (test(value)) {
          element = new ElementClass(value);
          break;
        }
      }

      return element;
    }

    /*
     * Get an element class given an element name.
     */

  }, {
    key: 'getElementClass',
    value: function getElementClass(element) {
      var ElementClass = this.elementMap[element];

      if (ElementClass === undefined) {
        // Fall back to the base element. We may not know what
        // to do with the `content`, but downstream software
        // may know.
        return this.Element;
      }

      return ElementClass;
    }

    /*
     * Convert a refract document into refract element instances.
     */

  }, {
    key: 'fromRefract',
    value: function fromRefract(doc) {
      return this.serialiser.deserialise(doc);
    }

    /*
     * Convert an element to a Refracted JSON object.
     */

  }, {
    key: 'toRefract',
    value: function toRefract(element) {
      return this.serialiser.serialise(element);
    }

    /*
     * Get an object that contains all registered element classes, where
     * the key is the PascalCased element name and the value is the class.
     */

  }, {
    key: 'elements',
    get: function get() {
      var _this = this;

      if (this._elements === undefined) {
        this._elements = {
          Element: this.Element
        };

        Object.keys(this.elementMap).forEach(function (name) {
          // Currently, all registered element types use a camelCaseName.
          // Converting to PascalCase is as simple as upper-casing the first
          // letter.
          var pascal = name[0].toUpperCase() + name.substr(1);
          _this._elements[pascal] = _this.elementMap[name];
        });
      }

      return this._elements;
    }

    /**
     * Convinience method for getting a JSON Serialiser configured with the
     * current namespace
     *
     * @type JSONSerialiser
     * @readonly
     *
     * @memberof Namespace.prototype
     */

  }, {
    key: 'serialiser',
    get: function get() {
      return new JSONSerialiser(this);
    }
  }]);

  return Namespace;
}();

JSONSerialiser.prototype.Namespace = Namespace;

module.exports = Namespace;

},{"./elements":5,"./serialisers/JSONSerialiser":18,"lodash/isBoolean":98,"lodash/isNull":103,"lodash/isNumber":104,"lodash/isObject":105,"lodash/isString":107}],4:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var negate = require('lodash/negate');
var ArraySlice = require('./ArraySlice');

/**
 */

var ObjectSlice = function (_ArraySlice) {
  _inherits(ObjectSlice, _ArraySlice);

  function ObjectSlice() {
    _classCallCheck(this, ObjectSlice);

    return _possibleConstructorReturn(this, (ObjectSlice.__proto__ || Object.getPrototypeOf(ObjectSlice)).apply(this, arguments));
  }

  _createClass(ObjectSlice, [{
    key: 'map',
    value: function map(callback, thisArg) {
      return this.elements.map(function (member) {
        return callback.bind(thisArg)(member.value, member.key, member);
      });
    }
  }, {
    key: 'filter',
    value: function filter(callback, thisArg) {
      return new ObjectSlice(this.elements.filter(function (member) {
        return callback.bind(thisArg)(member.value, member.key, member);
      }));
    }
  }, {
    key: 'reject',
    value: function reject(callback, thisArg) {
      return this.filter(negate(callback.bind(thisArg)));
    }
  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      return this.elements.forEach(function (member, index) {
        callback.bind(thisArg)(member.value, member.key, member, index);
      });
    }

    /**
     * @returns {array}
     */

  }, {
    key: 'keys',
    value: function keys() {
      return this.map(function (value, key) {
        return key.toValue();
      });
    }

    /**
     * @returns {array}
     */

  }, {
    key: 'values',
    value: function values() {
      return this.map(function (value) {
        return value.toValue();
      });
    }
  }]);

  return ObjectSlice;
}(ArraySlice);

module.exports = ObjectSlice;

},{"./ArraySlice":1,"lodash/negate":110}],5:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var Element = require('./primitives/Element');
var NullElement = require('./primitives/NullElement');
var StringElement = require('./primitives/StringElement');
var NumberElement = require('./primitives/NumberElement');
var BooleanElement = require('./primitives/BooleanElement');
var ArrayElement = require('./primitives/ArrayElement');
var MemberElement = require('./primitives/MemberElement');
var ObjectElement = require('./primitives/ObjectElement');
var LinkElement = require('./elements/LinkElement');
var RefElement = require('./elements/RefElement');

var ArraySlice = require('./ArraySlice');
var ObjectSlice = require('./ObjectSlice');

var KeyValuePair = require('./KeyValuePair');

/**
 * Refracts a JSON type to minim elements
 * @param value
 * @returns {Element}
 */
function refract(value) {
  if (value instanceof Element) {
    return value;
  }

  if (typeof value === 'string') {
    return new StringElement(value);
  }

  if (typeof value === 'number') {
    return new NumberElement(value);
  }

  if (typeof value === 'boolean') {
    return new BooleanElement(value);
  }

  if (value === null) {
    return new NullElement();
  }

  if (Array.isArray(value)) {
    return new ArrayElement(value.map(refract));
  }

  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
    var element = new ObjectElement(value);
    return element;
  }

  return value;
}

Element.prototype.ObjectElement = ObjectElement;
Element.prototype.RefElement = RefElement;
Element.prototype.MemberElement = MemberElement;

Element.prototype.refract = refract;
ArraySlice.prototype.refract = refract;

/**
 * Contains all of the element classes, and related structures and methods
 * for handling with element instances.
 */
module.exports = {
  Element: Element,
  NullElement: NullElement,
  StringElement: StringElement,
  NumberElement: NumberElement,
  BooleanElement: BooleanElement,
  ArrayElement: ArrayElement,
  MemberElement: MemberElement,
  ObjectElement: ObjectElement,
  LinkElement: LinkElement,
  RefElement: RefElement,

  refract: refract,

  ArraySlice: ArraySlice,
  ObjectSlice: ObjectSlice,
  KeyValuePair: KeyValuePair
};

},{"./ArraySlice":1,"./KeyValuePair":2,"./ObjectSlice":4,"./elements/LinkElement":6,"./elements/RefElement":7,"./primitives/ArrayElement":9,"./primitives/BooleanElement":10,"./primitives/Element":11,"./primitives/MemberElement":12,"./primitives/NullElement":13,"./primitives/NumberElement":14,"./primitives/ObjectElement":15,"./primitives/StringElement":16}],6:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Element = require('../primitives/Element');

/** Hyperlinking MAY be used to link to other resources, provide links to
 * instructions on how to process a given element (by way of a profile or
 * other means), and may be used to provide meta data about the element in
 * which it's found. The meaning and purpose of the hyperlink is defined by
 * the link relation according to RFC 5988.
 *
 * @class LinkElement
 *
 * @param content
 * @param meta
 * @param attributes
 */
module.exports = function (_Element) {
  _inherits(LinkElement, _Element);

  function LinkElement(content, meta, attributes) {
    _classCallCheck(this, LinkElement);

    var _this = _possibleConstructorReturn(this, (LinkElement.__proto__ || Object.getPrototypeOf(LinkElement)).call(this, content || [], meta, attributes));

    _this.element = 'link';
    return _this;
  }

  /**
   * The relation identifier for the link, as defined in RFC 5988.
   * @type StringElement
   */

  _createClass(LinkElement, [{
    key: 'relation',
    get: function get() {
      return this.attributes.get('relation');
    },
    set: function set(relation) {
      this.attributes.set('relation', relation);
    }

    /**
     * The URI for the given link.
     * @type StringElement
     */

  }, {
    key: 'href',
    get: function get() {
      return this.attributes.get('href');
    },
    set: function set(href) {
      this.attributes.set('href', href);
    }
  }]);

  return LinkElement;
}(Element);

},{"../primitives/Element":11}],7:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Element = require('../primitives/Element');

/**
 * @class RefElement
 *
 * @param content
 * @param meta
 * @param attributes
 *
 * @extends Element
 */
module.exports = function (_Element) {
  _inherits(RefElement, _Element);

  function RefElement(content, meta, attributes) {
    _classCallCheck(this, RefElement);

    var _this = _possibleConstructorReturn(this, (RefElement.__proto__ || Object.getPrototypeOf(RefElement)).call(this, content || [], meta, attributes));

    _this.element = 'ref';

    if (!_this.path) {
      _this.path = 'element';
    }
    return _this;
  }

  /**
   * Path of referenced element to transclude instead of element itself.
   * @type StringElement
   * @default element
   */

  _createClass(RefElement, [{
    key: 'path',
    get: function get() {
      return this.attributes.get('path');
    },
    set: function set(newValue) {
      this.attributes.set('path', newValue);
    }
  }]);

  return RefElement;
}(Element);

},{"../primitives/Element":11}],8:[function(require,module,exports){
'use strict';

var Namespace = require('./Namespace');
var elements = require('./elements');

// Direct access to the Namespace class
exports.Namespace = Namespace;

// Special constructor for the Namespace class
exports.namespace = function namespace(options) {
  return new Namespace(options);
};

exports.KeyValuePair = require('./KeyValuePair');

exports.ArraySlice = elements.ArraySlice;
exports.ObjectSlice = elements.ObjectSlice;

exports.Element = elements.Element;
exports.StringElement = elements.StringElement;
exports.NumberElement = elements.NumberElement;
exports.BooleanElement = elements.BooleanElement;
exports.NullElement = elements.NullElement;
exports.ArrayElement = elements.ArrayElement;
exports.ObjectElement = elements.ObjectElement;
exports.MemberElement = elements.MemberElement;
exports.RefElement = elements.RefElement;
exports.LinkElement = elements.LinkElement;

exports.refract = elements.refract;

exports.JSONSerialiser = require('./serialisers/JSONSerialiser');
exports.JSON06Serialiser = require('./serialisers/JSON06Serialiser');

},{"./KeyValuePair":2,"./Namespace":3,"./elements":5,"./serialisers/JSON06Serialiser":17,"./serialisers/JSONSerialiser":18}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var negate = require('lodash/negate');
var Element = require('./Element');
var ArraySlice = require('../ArraySlice');

/**
 * @class
 *
 * @param {Element[]} content
 * @param meta
 * @param attributes
 */

var ArrayElement = function (_Element) {
  _inherits(ArrayElement, _Element);

  function ArrayElement(content, meta, attributes) {
    _classCallCheck(this, ArrayElement);

    var _this = _possibleConstructorReturn(this, (ArrayElement.__proto__ || Object.getPrototypeOf(ArrayElement)).call(this, content || [], meta, attributes));

    _this.element = 'array';
    return _this;
  }

  _createClass(ArrayElement, [{
    key: 'primitive',
    value: function primitive() {
      return 'array';
    }

    /**
     * @returns {Element}
     */

  }, {
    key: 'get',
    value: function get(index) {
      return this.content[index];
    }

    /**
     * Helper for returning the value of an item
     * This works for both ArrayElement and ObjectElement instances
     */

  }, {
    key: 'getValue',
    value: function getValue(indexOrKey) {
      var item = this.get(indexOrKey);

      if (item) {
        return item.toValue();
      }

      return undefined;
    }

    /**
     * @returns {Element}
     */

  }, {
    key: 'getIndex',
    value: function getIndex(index) {
      return this.content[index];
    }
  }, {
    key: 'set',
    value: function set(index, value) {
      this.content[index] = this.refract(value);
      return this;
    }
  }, {
    key: 'remove',
    value: function remove(index) {
      var removed = this.content.splice(index, 1);

      if (removed.length) {
        return removed[0];
      }

      return null;
    }

    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     */

  }, {
    key: 'map',
    value: function map(callback, thisArg) {
      return this.content.map(callback, thisArg);
    }

    /**
     * Maps and then flattens the results.
     * @param callback - Function to execute for each element.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {array}
     */

  }, {
    key: 'flatMap',
    value: function flatMap(callback, thisArg) {
      return this.map(callback, thisArg).reduce(function (a, b) {
        return a.concat(b);
      }, []);
    }

    /**
     * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
     * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArrayElement.prototype
     * @returns An array of the non-undefined results of calling transform with each element of the array
     */

  }, {
    key: 'compactMap',
    value: function compactMap(transform, thisArg) {
      var results = [];

      this.forEach(function (element) {
        var result = transform.bind(thisArg)(element);

        if (result) {
          results.push(result);
        }
      });

      return results;
    }

    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     */

  }, {
    key: 'filter',
    value: function filter(callback, thisArg) {
      return new ArraySlice(this.content.filter(callback, thisArg));
    }

    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     */

  }, {
    key: 'reject',
    value: function reject(callback, thisArg) {
      return this.filter(negate(callback), thisArg);
    }

    /**
     * This is a reduce function specifically for Minim arrays and objects. It
     * allows for returning normal values or Minim instances, so it converts any
     * primitives on each step.
     */

  }, {
    key: 'reduce',
    value: function reduce(callback, initialValue) {
      var startIndex = void 0;
      var memo = void 0;

      // Allows for defining a starting value of the reduce
      if (initialValue !== undefined) {
        startIndex = 0;
        memo = this.refract(initialValue);
      } else {
        startIndex = 1;
        // Object Element content items are member elements. Because of this,
        // the memo should start out as the member value rather than the
        // actual member itself.
        memo = this.primitive() === 'object' ? this.first.value : this.first;
      }

      // Sending each function call to the registry allows for passing Minim
      // instances through the function return. This means you can return
      // primitive values or return Minim instances and reduce will still work.
      for (var i = startIndex; i < this.length; i += 1) {
        var item = this.content[i];

        if (this.primitive() === 'object') {
          memo = this.refract(callback(memo, item.value, item.key, item, this));
        } else {
          memo = this.refract(callback(memo, item, i, this));
        }
      }

      return memo;
    }

    /**
     * @callback forEachCallback
     * @param {Element} currentValue
     * @param {NumberElement} index
     */

    /**
     * @param {forEachCallback} callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArrayElement.prototype
     */

  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      var _this2 = this;

      this.content.forEach(function (item, index) {
        callback.bind(thisArg)(item, _this2.refract(index));
      });
    }

    /**
     * @returns {Element}
     */

  }, {
    key: 'shift',
    value: function shift() {
      return this.content.shift();
    }

    /**
     * @param value
     */

  }, {
    key: 'unshift',
    value: function unshift(value) {
      this.content.unshift(this.refract(value));
    }

    /**
     * @param value
     */

  }, {
    key: 'push',
    value: function push(value) {
      this.content.push(this.refract(value));
      return this;
    }

    /**
     * @param value
     */

  }, {
    key: 'add',
    value: function add(value) {
      this.push(value);
    }

    /**
     * Recusively search all descendents using a condition function.
     * @returns {Element[]}
     */

  }, {
    key: 'findElements',
    value: function findElements(condition, givenOptions) {
      var options = givenOptions || {};
      var recursive = !!options.recursive;
      var results = options.results === undefined ? [] : options.results;

      // The forEach method for Object Elements returns value, key, and member.
      // This passes those along to the condition function below.
      this.forEach(function (item, keyOrIndex, member) {
        // We use duck-typing here to support any registered class that
        // may contain other elements.
        if (recursive && item.findElements !== undefined) {
          item.findElements(condition, {
            results: results,
            recursive: recursive
          });
        }

        if (condition(item, keyOrIndex, member)) {
          results.push(item);
        }
      });

      return results;
    }

    /**
     * Recusively search all descendents using a condition function.
     * @param condition
     * @returns {ArraySlice}
     */

  }, {
    key: 'find',
    value: function find(condition) {
      return new ArraySlice(this.findElements(condition, { recursive: true }));
    }

    /**
     * @param {string} element
     * @returns {ArraySlice}
     */

  }, {
    key: 'findByElement',
    value: function findByElement(element) {
      return this.find(function (item) {
        return item.element === element;
      });
    }

    /**
     * @param {string} className
     * @returns {ArraySlice}
     * @memberof ArrayElement.prototype
     */

  }, {
    key: 'findByClass',
    value: function findByClass(className) {
      return this.find(function (item) {
        return item.classes.contains(className);
      });
    }

    /**
     * Search the tree recursively and find the element with the matching ID
     * @param {string} id
     * @returns {Element}
     * @memberof ArrayElement.prototype
     */

  }, {
    key: 'getById',
    value: function getById(id) {
      return this.find(function (item) {
        return item.id.toValue() === id;
      }).first;
    }

    /**
     * Looks for matching children using deep equality
     * @param value
     * @returns {boolean}
     */

  }, {
    key: 'contains',
    value: function contains(value) {
      return this.content.some(function (element) {
        return element.equals(value);
      });
    }

    // Fantasy Land

    /**
     * @returns {ArrayElement} An empty array element
     */

  }, {
    key: 'empty',
    value: function empty() {
      return new this.constructor([]);
    }
  }, {
    key: 'fantasy-land/empty',
    value: function fantasyLandEmpty() {
      return this.empty();
    }

    /**
     * @param {ArrayElement} other
     * @returns {ArrayElement}
     */

  }, {
    key: 'concat',
    value: function concat(other) {
      return new this.constructor(this.content.concat(other.content));
    }
  }, {
    key: 'fantasy-land/concat',
    value: function fantasyLandConcat(other) {
      return this.concat(other);
    }
  }, {
    key: 'fantasy-land/map',
    value: function fantasyLandMap(transform) {
      return new this.constructor(this.map(transform));
    }
  }, {
    key: 'fantasy-land/chain',
    value: function fantasyLandChain(transform) {
      return this.map(function (element) {
        return transform(element);
      }, this).reduce(function (a, b) {
        return a.concat(b);
      }, this.empty());
    }
  }, {
    key: 'fantasy-land/filter',
    value: function fantasyLandFilter(callback) {
      return new this.constructor(this.content.filter(callback));
    }
  }, {
    key: 'fantasy-land/reduce',
    value: function fantasyLandReduce(transform, initialValue) {
      return this.content.reduce(transform, initialValue);
    }

    /**
     * Returns the length of the collection
     * @type number
     */

  }, {
    key: 'length',
    get: function get() {
      return this.content.length;
    }

    /**
     * Returns whether the collection is empty
     * @type boolean
     */

  }, {
    key: 'isEmpty',
    get: function get() {
      return this.content.length === 0;
    }

    /**
     * Return the first item in the collection
     * @type Element
     */

  }, {
    key: 'first',
    get: function get() {
      return this.getIndex(0);
    }

    /**
     * Return the second item in the collection
     * @type Element
     */

  }, {
    key: 'second',
    get: function get() {
      return this.getIndex(1);
    }

    /**
     * Return the last item in the collection
     * @type Element
     */

  }, {
    key: 'last',
    get: function get() {
      return this.getIndex(this.length - 1);
    }
  }]);

  return ArrayElement;
}(Element);

/**
 * @returns {ArrayElement} An empty array element
 */

ArrayElement.empty = function empty() {
  return new this();
};

ArrayElement['fantasy-land/empty'] = ArrayElement.empty;

if (typeof Symbol !== 'undefined') {
  ArrayElement.prototype[Symbol.iterator] = function symbol() {
    return this.content[Symbol.iterator]();
  };
}

module.exports = ArrayElement;

},{"../ArraySlice":1,"./Element":11,"lodash/negate":110}],10:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Element = require('./Element');

/**
 * @class BooleanElement
 *
 * @param {boolean} content
 * @param meta
 * @param attributes
 */
module.exports = function (_Element) {
  _inherits(BooleanElement, _Element);

  function BooleanElement(content, meta, attributes) {
    _classCallCheck(this, BooleanElement);

    var _this = _possibleConstructorReturn(this, (BooleanElement.__proto__ || Object.getPrototypeOf(BooleanElement)).call(this, content, meta, attributes));

    _this.element = 'boolean';
    return _this;
  }

  _createClass(BooleanElement, [{
    key: 'primitive',
    value: function primitive() {
      return 'boolean';
    }
  }]);

  return BooleanElement;
}(Element);

},{"./Element":11}],11:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var isEqual = require('lodash/isEqual');
var KeyValuePair = require('../KeyValuePair');
var ArraySlice = require('../ArraySlice.js');

/**
 * @class
 *
 * @param content
 * @param meta
 * @param attributes
 *
 * @property {string} element
 */

var Element = function () {
  function Element(content, meta, attributes) {
    _classCallCheck(this, Element);

    // Lazy load this.meta and this.attributes because it's a Minim element
    // Otherwise, we get into circuluar calls
    if (meta) {
      this.meta = meta;
    }

    if (attributes) {
      this.attributes = attributes;
    }

    this.content = content;
  }

  /**
   * Freezes the element to prevent any mutation.
   * A frozen element will add `parent` property to every child element
   * to allow traversing up the element tree.
   */

  _createClass(Element, [{
    key: 'freeze',
    value: function freeze() {
      var _this = this;

      if (Object.isFrozen(this)) {
        return;
      }

      if (this._meta) {
        this.meta.parent = this;
        this.meta.freeze();
      }

      if (this._attributes) {
        this.attributes.parent = this;
        this.attributes.freeze();
      }

      this.children.forEach(function (element) {
        element.parent = _this;
        element.freeze();
      }, this);

      if (this.content && Array.isArray(this.content)) {
        Object.freeze(this.content);
      }

      Object.freeze(this);
    }
  }, {
    key: 'primitive',
    value: function primitive() {}

    /**
     * Creates a deep clone of the instance
     */

  }, {
    key: 'clone',
    value: function clone() {
      var copy = new this.constructor();

      copy.element = this.element;

      if (this.meta.length) {
        copy._meta = this.meta.clone();
      }

      if (this.attributes.length) {
        copy._attributes = this.attributes.clone();
      }

      if (this.content) {
        if (this.content.clone) {
          copy.content = this.content.clone();
        } else if (Array.isArray(this.content)) {
          copy.content = this.content.map(function (element) {
            return element.clone();
          });
        } else {
          copy.content = this.content;
        }
      } else {
        copy.content = this.content;
      }

      return copy;
    }

    /**
     */

  }, {
    key: 'toValue',
    value: function toValue() {
      if (this.content instanceof Element) {
        return this.content.toValue();
      }

      if (this.content instanceof KeyValuePair) {
        return {
          key: this.content.key.toValue(),
          value: this.content.value.toValue()
        };
      }

      if (this.content && this.content.map) {
        return this.content.map(function (element) {
          return element.toValue();
        }, this);
      }

      return this.content;
    }

    /**
     * Creates a reference pointing at the Element
     * @returns {RefElement}
     * @memberof Element.prototype
     */

  }, {
    key: 'toRef',
    value: function toRef(path) {
      if (this.id.toValue() === '') {
        throw Error('Cannot create reference to an element that does not contain an ID');
      }

      var ref = new this.RefElement(this.id.toValue());

      if (path) {
        ref.path = path;
      }

      return ref;
    }

    /**
     * Finds the given elements in the element tree.
     * When providing multiple element names, you must first freeze the element.
     *
     * @param names {...elementNames}
     * @returns {ArraySlice}
     */

  }, {
    key: 'findRecursive',
    value: function findRecursive() {
      for (var _len = arguments.length, elementNames = Array(_len), _key = 0; _key < _len; _key++) {
        elementNames[_key] = arguments[_key];
      }

      if (arguments.length > 1 && !this.isFrozen) {
        throw new Error('Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`');
      }

      var elementName = elementNames.pop();
      var elements = new ArraySlice();

      var append = function append(array, element) {
        array.push(element);
        return array;
      };

      // Checks the given element and appends element/sub-elements
      // that match element name to given array
      var checkElement = function checkElement(array, element) {
        if (element.element === elementName) {
          array.push(element);
        }

        var items = element.findRecursive(elementName);
        if (items) {
          items.reduce(append, array);
        }

        if (element.content instanceof KeyValuePair) {
          if (element.content.key) {
            checkElement(array, element.content.key);
          }

          if (element.content.value) {
            checkElement(array, element.content.value);
          }
        }

        return array;
      };

      if (this.content) {
        // Direct Element
        if (this.content.element) {
          checkElement(elements, this.content);
        }

        // Element Array
        if (Array.isArray(this.content)) {
          this.content.reduce(checkElement, elements);
        }
      }

      if (!elementNames.isEmpty) {
        elements = elements.filter(function (element) {
          var parentElements = element.parents.map(function (e) {
            return e.element;
          });

          // eslint-disable-next-line no-restricted-syntax
          for (var namesIndex in elementNames) {
            var name = elementNames[namesIndex];
            var index = parentElements.indexOf(name);

            if (index !== -1) {
              parentElements = parentElements.splice(0, index);
            } else {
              return false;
            }
          }

          return true;
        });
      }

      return elements;
    }
  }, {
    key: 'set',
    value: function set(content) {
      this.content = content;
      return this;
    }
  }, {
    key: 'equals',
    value: function equals(value) {
      return isEqual(this.toValue(), value);
    }
  }, {
    key: 'getMetaProperty',
    value: function getMetaProperty(name, value) {
      if (!this.meta.hasKey(name)) {
        if (this.isFrozen) {
          var element = this.refract(value);
          element.freeze();
          return element;
        }

        this.meta.set(name, value);
      }

      return this.meta.get(name);
    }
  }, {
    key: 'setMetaProperty',
    value: function setMetaProperty(name, value) {
      this.meta.set(name, value);
    }

    /**
     * @type String
     */

  }, {
    key: 'element',
    get: function get() {
      // Returns 'element' so we don't have undefined as element
      return this._storedElement || 'element';
    },
    set: function set(element) {
      this._storedElement = element;
    }
  }, {
    key: 'content',
    get: function get() {
      return this._content;
    },
    set: function set(value) {
      var _this2 = this;

      if (value instanceof Element) {
        this._content = value;
      } else if (value instanceof ArraySlice) {
        this.content = value.elements;
      } else if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean' || value === 'null' || value == undefined) {
        // Primitive Values
        this._content = value;
      } else if (value instanceof KeyValuePair) {
        this._content = value;
      } else if (Array.isArray(value)) {
        this._content = value.map(this.refract);
      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
        this._content = Object.keys(value).map(function (key) {
          return new _this2.MemberElement(key, value[key]);
        });
      } else {
        throw new Error('Cannot set content to given value');
      }
    }

    /**
     * @type ObjectElement
     */

  }, {
    key: 'meta',
    get: function get() {
      if (!this._meta) {
        if (this.isFrozen) {
          var meta = new this.ObjectElement();
          meta.freeze();
          return meta;
        }

        this._meta = new this.ObjectElement();
      }

      return this._meta;
    },
    set: function set(value) {
      if (value instanceof this.ObjectElement) {
        this._meta = value;
      } else {
        this.meta.set(value || {});
      }
    }

    /**
     * The attributes property defines attributes about the given instance
     * of the element, as specified by the element property.
     *
     * @type ObjectElement
     */

  }, {
    key: 'attributes',
    get: function get() {
      if (!this._attributes) {
        if (this.isFrozen) {
          var meta = new this.ObjectElement();
          meta.freeze();
          return meta;
        }

        this._attributes = new this.ObjectElement();
      }

      return this._attributes;
    },
    set: function set(value) {
      if (value instanceof this.ObjectElement) {
        this._attributes = value;
      } else {
        this.attributes.set(value || {});
      }
    }

    /**
     * Unique Identifier, MUST be unique throughout an entire element tree.
     * @type StringElement
     */

  }, {
    key: 'id',
    get: function get() {
      return this.getMetaProperty('id', '');
    },
    set: function set(element) {
      this.setMetaProperty('id', element);
    }

    /**
     * @type ArrayElement
     */

  }, {
    key: 'classes',
    get: function get() {
      return this.getMetaProperty('classes', []);
    },
    set: function set(element) {
      this.setMetaProperty('classes', element);
    }

    /**
     * Human-readable title of element
     * @type StringElement
     */

  }, {
    key: 'title',
    get: function get() {
      return this.getMetaProperty('title', '');
    },
    set: function set(element) {
      this.setMetaProperty('title', element);
    }

    /**
     * Human-readable description of element
     * @type StringElement
     */

  }, {
    key: 'description',
    get: function get() {
      return this.getMetaProperty('description', '');
    },
    set: function set(element) {
      this.setMetaProperty('description', element);
    }

    /**
     * @type ArrayElement
     */

  }, {
    key: 'links',
    get: function get() {
      return this.getMetaProperty('links', []);
    },
    set: function set(element) {
      this.setMetaProperty('links', element);
    }

    /**
     * Returns whether the element is frozen.
     * @type boolean
     * @see freeze
     */

  }, {
    key: 'isFrozen',
    get: function get() {
      return Object.isFrozen(this);
    }

    /**
     * Returns all of the parent elements.
     * @type ArraySlice
     */

  }, {
    key: 'parents',
    get: function get() {
      var parent = this.parent;

      var parents = new ArraySlice();

      while (parent) {
        parents.push(parent);

        // eslint-disable-next-line prefer-destructuring
        parent = parent.parent;
      }

      return parents;
    }

    /**
     * Returns all of the children elements found within the element.
     * @type ArraySlice
     * @see recursiveChildren
     */

  }, {
    key: 'children',
    get: function get() {
      if (Array.isArray(this.content)) {
        return new ArraySlice(this.content);
      }

      if (this.content instanceof KeyValuePair) {
        var children = new ArraySlice([this.content.key]);

        if (this.content.value) {
          children.push(this.content.value);
        }

        return children;
      }

      if (this.content instanceof Element) {
        return new ArraySlice([this.content]);
      }

      return new ArraySlice();
    }

    /**
    * Returns all of the children elements found within the element recursively.
    * @type ArraySlice
    * @see children
    */

  }, {
    key: 'recursiveChildren',
    get: function get() {
      var children = new ArraySlice();

      this.children.forEach(function (element) {
        children.push(element);

        element.recursiveChildren.forEach(function (child) {
          children.push(child);
        });
      });

      return children;
    }
  }]);

  return Element;
}();

module.exports = Element;

},{"../ArraySlice.js":1,"../KeyValuePair":2,"lodash/isEqual":100}],12:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var KeyValuePair = require('../KeyValuePair');
var Element = require('./Element');

/**
 * @class MemberElement
 *
 * @param {Element} key
 * @param {Element} value
 * @param meta
 * @param attributes
 */
module.exports = function (_Element) {
  _inherits(MemberElement, _Element);

  function MemberElement(key, value, meta, attributes) {
    _classCallCheck(this, MemberElement);

    var _this = _possibleConstructorReturn(this, (MemberElement.__proto__ || Object.getPrototypeOf(MemberElement)).call(this, new KeyValuePair(), meta, attributes));

    _this.element = 'member';
    _this.key = key;
    _this.value = value;
    return _this;
  }

  /**
   * @type Element
   */

  _createClass(MemberElement, [{
    key: 'key',
    get: function get() {
      return this.content.key;
    },
    set: function set(key) {
      this.content.key = this.refract(key);
    }

    /**
     * @type Element
     */

  }, {
    key: 'value',
    get: function get() {
      return this.content.value;
    },
    set: function set(value) {
      this.content.value = this.refract(value);
    }
  }]);

  return MemberElement;
}(Element);

},{"../KeyValuePair":2,"./Element":11}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Element = require('./Element');

/**
 */

var NullElement = function (_Element) {
  _inherits(NullElement, _Element);

  function NullElement(content, meta, attributes) {
    _classCallCheck(this, NullElement);

    var _this = _possibleConstructorReturn(this, (NullElement.__proto__ || Object.getPrototypeOf(NullElement)).call(this, content || null, meta, attributes));

    _this.element = 'null';
    return _this;
  }

  _createClass(NullElement, [{
    key: 'primitive',
    value: function primitive() {
      return 'null';
    }
  }, {
    key: 'set',
    value: function set() {
      return new Error('Cannot set the value of null');
    }
  }]);

  return NullElement;
}(Element);

module.exports = NullElement;

},{"./Element":11}],14:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Element = require('./Element');

/**
 * @class NumberElement
 *
 * @param {number} content
 * @param meta
 * @param attributes
 */
module.exports = function (_Element) {
  _inherits(NumberElement, _Element);

  function NumberElement(content, meta, attributes) {
    _classCallCheck(this, NumberElement);

    var _this = _possibleConstructorReturn(this, (NumberElement.__proto__ || Object.getPrototypeOf(NumberElement)).call(this, content, meta, attributes));

    _this.element = 'number';
    return _this;
  }

  _createClass(NumberElement, [{
    key: 'primitive',
    value: function primitive() {
      return 'number';
    }
  }]);

  return NumberElement;
}(Element);

},{"./Element":11}],15:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var negate = require('lodash/negate');
var isObject = require('lodash/isObject');

var ArrayElement = require('./ArrayElement');
var MemberElement = require('./MemberElement');
var ObjectSlice = require('../ObjectSlice');

/**
 * @class
 *
 * @param content
 * @param meta
 * @param attributes
 */

var ObjectElement = function (_ArrayElement) {
  _inherits(ObjectElement, _ArrayElement);

  function ObjectElement(content, meta, attributes) {
    _classCallCheck(this, ObjectElement);

    var _this = _possibleConstructorReturn(this, (ObjectElement.__proto__ || Object.getPrototypeOf(ObjectElement)).call(this, content || [], meta, attributes));

    _this.element = 'object';
    return _this;
  }

  _createClass(ObjectElement, [{
    key: 'primitive',
    value: function primitive() {
      return 'object';
    }
  }, {
    key: 'toValue',
    value: function toValue() {
      return this.content.reduce(function (results, el) {
        results[el.key.toValue()] = el.value.toValue();
        return results;
      }, {});
    }

    /**
     * @param key
     * @returns {Element}
     */

  }, {
    key: 'get',
    value: function get(name) {
      var member = this.getMember(name);

      if (member) {
        return member.value;
      }

      return undefined;
    }

    /**
     * @param key
     * @returns {MemberElement}
     */

  }, {
    key: 'getMember',
    value: function getMember(name) {
      if (name === undefined) {
        return undefined;
      }

      return this.content.find(function (element) {
        return element.key.toValue() === name;
      });
    }

    /**
     * @param key
     */

  }, {
    key: 'remove',
    value: function remove(name) {
      var removed = null;

      this.content = this.content.filter(function (item) {
        if (item.key.toValue() === name) {
          removed = item;
          return false;
        }

        return true;
      });

      return removed;
    }

    /**
     * @param key
     * @returns {Element}
     */

  }, {
    key: 'getKey',
    value: function getKey(name) {
      var member = this.getMember(name);

      if (member) {
        return member.key;
      }

      return undefined;
    }

    /**
     * Set allows either a key/value pair to be given or an object
     * If an object is given, each key is set to its respective value
     */

  }, {
    key: 'set',
    value: function set(keyOrObject, value) {
      var _this2 = this;

      if (isObject(keyOrObject)) {
        Object.keys(keyOrObject).forEach(function (objectKey) {
          _this2.set(objectKey, keyOrObject[objectKey]);
        });

        return this;
      }

      // Store as key for clarity
      var key = keyOrObject;
      var member = this.getMember(key);

      if (member) {
        member.value = value;
      } else {
        this.content.push(new MemberElement(key, value));
      }

      return this;
    }

    /**
     */

  }, {
    key: 'keys',
    value: function keys() {
      return this.content.map(function (item) {
        return item.key.toValue();
      });
    }

    /**
     */

  }, {
    key: 'values',
    value: function values() {
      return this.content.map(function (item) {
        return item.value.toValue();
      });
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasKey',
    value: function hasKey(value) {
      for (var i = 0; i < this.content.length; i += 1) {
        if (this.content[i].key.equals(value)) {
          return true;
        }
      }

      return false;
    }

    /**
     * @returns {array}
     */

  }, {
    key: 'items',
    value: function items() {
      return this.content.map(function (item) {
        return [item.key.toValue(), item.value.toValue()];
      });
    }

    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     */

  }, {
    key: 'map',
    value: function map(callback, thisArg) {
      return this.content.map(function (item) {
        return callback.bind(thisArg)(item.value, item.key, item);
      });
    }

    /**
     * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
     * @param transform - A closure that accepts the value, key and member element of this object as its argument and returns an optional value.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns An array of the non-undefined results of calling transform with each element of the array
     */

  }, {
    key: 'compactMap',
    value: function compactMap(callback, thisArg) {
      var results = [];

      this.forEach(function (value, key, member) {
        var result = callback.bind(thisArg)(value, key, member);

        if (result) {
          results.push(result);
        }
      });

      return results;
    }

    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     *
     * @returns {ObjectSlice}
     */

  }, {
    key: 'filter',
    value: function filter(callback, thisArg) {
      return new ObjectSlice(this.content).filter(callback, thisArg);
    }

    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     *
     * @returns {ObjectSlice}
     *
     * @memberof ObjectElement.prototype
     */

  }, {
    key: 'reject',
    value: function reject(callback, thisArg) {
      return this.filter(negate(callback), thisArg);
    }

    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     *
     * @memberof ObjectElement.prototype
     */

  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      return this.content.forEach(function (item) {
        return callback.bind(thisArg)(item.value, item.key, item);
      });
    }
  }]);

  return ObjectElement;
}(ArrayElement);

module.exports = ObjectElement;

},{"../ObjectSlice":4,"./ArrayElement":9,"./MemberElement":12,"lodash/isObject":105,"lodash/negate":110}],16:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Element = require('./Element');

/**
 * @class StringElement
 *
 * @param {string} content
 * @param meta
 * @param attributes
 */
module.exports = function (_Element) {
  _inherits(StringElement, _Element);

  function StringElement(content, meta, attributes) {
    _classCallCheck(this, StringElement);

    var _this = _possibleConstructorReturn(this, (StringElement.__proto__ || Object.getPrototypeOf(StringElement)).call(this, content, meta, attributes));

    _this.element = 'string';
    return _this;
  }

  _createClass(StringElement, [{
    key: 'primitive',
    value: function primitive() {
      return 'string';
    }

    /**
     * The length of the string.
     * @type number
     */

  }, {
    key: 'length',
    get: function get() {
      return this.content.length;
    }
  }]);

  return StringElement;
}(Element);

},{"./Element":11}],17:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;_e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }return _arr;
  }return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var JSONSerialiser = require('./JSONSerialiser');

module.exports = function (_JSONSerialiser) {
  _inherits(JSON06Serialiser, _JSONSerialiser);

  function JSON06Serialiser() {
    _classCallCheck(this, JSON06Serialiser);

    return _possibleConstructorReturn(this, (JSON06Serialiser.__proto__ || Object.getPrototypeOf(JSON06Serialiser)).apply(this, arguments));
  }

  _createClass(JSON06Serialiser, [{
    key: 'serialise',
    value: function serialise(element) {
      if (!(element instanceof this.namespace.elements.Element)) {
        throw new TypeError('Given element `' + element + '` is not an Element instance');
      }

      var variable = void 0;
      if (element._attributes && element.attributes.get('variable')) {
        variable = element.attributes.get('variable');
      }

      var payload = {
        element: element.element
      };

      if (element._meta && element._meta.length > 0) {
        payload.meta = this.serialiseObject(element.meta);
      }

      var isEnum = element.element === 'enum' || element.attributes.keys().indexOf('enumerations') !== -1;

      if (isEnum) {
        var attributes = this.enumSerialiseAttributes(element);

        if (attributes) {
          payload.attributes = attributes;
        }
      } else if (element._attributes && element._attributes.length > 0) {
        var _attributes = element.attributes;

        // Meta attribute was renamed to metadata

        if (_attributes.get('metadata')) {
          _attributes = _attributes.clone();
          _attributes.set('meta', _attributes.get('metadata'));
          _attributes.remove('metadata');
        }

        if (element.element === 'member' && variable) {
          _attributes = _attributes.clone();
          _attributes.remove('variable');
        }

        if (_attributes.length > 0) {
          payload.attributes = this.serialiseObject(_attributes);
        }
      }

      if (isEnum) {
        payload.content = this.enumSerialiseContent(element, payload);
      } else if (this[element.element + 'SerialiseContent']) {
        payload.content = this[element.element + 'SerialiseContent'](element, payload);
      } else if (element.content !== undefined) {
        var content = void 0;

        if (variable && element.content.key) {
          content = element.content.clone();
          content.key.attributes.set('variable', variable);
          content = this.serialiseContent(content);
        } else {
          content = this.serialiseContent(element.content);
        }

        if (this.shouldSerialiseContent(element, content)) {
          payload.content = content;
        }
      }

      return payload;
    }
  }, {
    key: 'shouldSerialiseContent',
    value: function shouldSerialiseContent(element, content) {
      if (content === undefined) {
        return false;
      }

      if (element.element === 'parseResult' || element.element === 'httpRequest' || element.element === 'httpResponse' || element.element === 'category' || element.element === 'link') {
        return true;
      }

      if (Array.isArray(content) && content.length === 0) {
        return false;
      }

      return true;
    }
  }, {
    key: 'refSerialiseContent',
    value: function refSerialiseContent(element, payload) {
      delete payload.attributes;

      return {
        href: element.toValue(),
        path: element.path.toValue()
      };
    }
  }, {
    key: 'sourceMapSerialiseContent',
    value: function sourceMapSerialiseContent(element) {
      return element.toValue();
    }
  }, {
    key: 'dataStructureSerialiseContent',
    value: function dataStructureSerialiseContent(element) {
      return [this.serialiseContent(element.content)];
    }
  }, {
    key: 'enumSerialiseAttributes',
    value: function enumSerialiseAttributes(element) {
      var _this2 = this;

      var attributes = element.attributes.clone();

      // Enumerations attribute was is placed inside content (see `enumSerialiseContent` below)
      var enumerations = attributes.remove('enumerations') || new this.namespace.elements.Array([]);

      // Remove fixed type attribute from samples and default
      var defaultValue = attributes.get('default');
      var samples = attributes.get('samples') || new this.namespace.elements.Array([]);

      if (defaultValue && defaultValue.content) {
        defaultValue.content.attributes.remove('typeAttributes');
        // Wrap default in array (not sure it is really needed because tests pass without this line)
        attributes.set('default', new this.namespace.elements.Array([defaultValue.content]));
      }

      // Strip typeAttributes from samples, 0.6 doesn't usually contain them in samples
      samples.forEach(function (sample) {
        if (sample.content && sample.content.element) {
          sample.content.attributes.remove('typeAttributes');
        }
      });

      // Content -> Samples
      if (element.content && enumerations.length !== 0) {
        // If we don't have enumerations, content should stay in
        // content (enumerations) as per Drafter 3 behaviour.
        samples.unshift(element.content);
      }

      samples = samples.map(function (sample) {
        if (sample instanceof _this2.namespace.elements.Array) {
          return [sample];
        }

        return new _this2.namespace.elements.Array([sample.content]);
      });

      if (samples.length) {
        attributes.set('samples', samples);
      }

      if (attributes.length > 0) {
        return this.serialiseObject(attributes);
      }

      return undefined;
    }
  }, {
    key: 'enumSerialiseContent',
    value: function enumSerialiseContent(element) {
      var _this3 = this;

      // In API Elements < 1.0, the content is the enumerations
      // If we don't have an enumerations, use the value (Drafter 3 behaviour)

      if (element._attributes) {
        var enumerations = element.attributes.get('enumerations');

        if (enumerations && enumerations.length > 0) {
          return enumerations.content.map(function (enumeration) {
            var e = enumeration.clone();
            e.attributes.remove('typeAttributes');
            return _this3.serialise(e);
          });
        }
      }

      if (element.content) {
        var value = element.content.clone();
        value.attributes.remove('typeAttributes');
        return [this.serialise(value)];
      }

      return [];
    }
  }, {
    key: 'deserialise',
    value: function deserialise(value) {
      if (typeof value === 'string') {
        return new this.namespace.elements.String(value);
      }

      if (typeof value === 'number') {
        return new this.namespace.elements.Number(value);
      }

      if (typeof value === 'boolean') {
        return new this.namespace.elements.Boolean(value);
      }

      if (value === null) {
        return new this.namespace.elements.Null();
      }

      if (Array.isArray(value)) {
        return new this.namespace.elements.Array(value.map(this.deserialise, this));
      }

      var ElementClass = this.namespace.getElementClass(value.element);
      var element = new ElementClass();

      if (element.element !== value.element) {
        element.element = value.element;
      }

      if (value.meta) {
        this.deserialiseObject(value.meta, element.meta);
      }

      if (value.attributes) {
        this.deserialiseObject(value.attributes, element.attributes);
      }

      var content = this.deserialiseContent(value.content);
      if (content !== undefined || element.content === null) {
        element.content = content;
      }

      if (element.element === 'enum') {
        // Grab enumerations from content
        if (element.content) {
          element.attributes.set('enumerations', element.content);
        }

        // Unwrap the sample value (inside double array)
        var samples = element.attributes.get('samples');
        element.attributes.remove('samples');

        if (samples) {
          // Re-wrap samples from array of array to array of enum's

          var existingSamples = samples;

          samples = new this.namespace.elements.Array();
          existingSamples.forEach(function (existingSample) {
            existingSample.forEach(function (sample) {
              var enumElement = new ElementClass(sample);
              enumElement.element = element.element;
              samples.push(enumElement);
            });
          });

          var sample = samples.shift();

          if (sample) {
            element.content = sample.content;
          } else {
            element.content = undefined;
          }

          element.attributes.set('samples', samples);
        } else {
          element.content = undefined;
        }

        // Unwrap the default value
        var defaultValue = element.attributes.get('default');
        if (defaultValue && defaultValue.length > 0) {
          defaultValue = defaultValue.get(0);
          var defaultElement = new ElementClass(defaultValue);
          defaultElement.element = element.element;
          element.attributes.set('default', defaultElement);
        }
      } else if (element.element === 'dataStructure' && Array.isArray(element.content)) {
        var _element$content = _slicedToArray(element.content, 1);

        element.content = _element$content[0];
      } else if (element.element === 'category') {
        // "meta" attribute has been renamed to metadata
        var metadata = element.attributes.get('meta');

        if (metadata) {
          element.attributes.set('metadata', metadata);
          element.attributes.remove('meta');
        }
      } else if (element.element === 'member' && element.key && element.key._attributes && element.key._attributes.getValue('variable')) {
        element.attributes.set('variable', element.key.attributes.get('variable'));
        element.key.attributes.remove('variable');
      }

      return element;
    }

    // Private API

  }, {
    key: 'serialiseContent',
    value: function serialiseContent(content) {
      if (content instanceof this.namespace.elements.Element) {
        return this.serialise(content);
      }

      if (content instanceof this.namespace.KeyValuePair) {
        var pair = {
          key: this.serialise(content.key)
        };

        if (content.value) {
          pair.value = this.serialise(content.value);
        }

        return pair;
      }

      if (content && content.map) {
        return content.map(this.serialise, this);
      }

      return content;
    }
  }, {
    key: 'deserialiseContent',
    value: function deserialiseContent(content) {
      if (content) {
        if (content.element) {
          return this.deserialise(content);
        }

        if (content.key) {
          var pair = new this.namespace.KeyValuePair(this.deserialise(content.key));

          if (content.value) {
            pair.value = this.deserialise(content.value);
          }

          return pair;
        }

        if (content.map) {
          return content.map(this.deserialise, this);
        }
      }

      return content;
    }
  }, {
    key: 'shouldRefract',
    value: function shouldRefract(element) {
      if (element._attributes && element.attributes.keys().length || element._meta && element.meta.keys().length) {
        return true;
      }

      if (element.element === 'enum') {
        // enum elements are treated like primitives (array)
        return false;
      }

      if (element.element !== element.primitive() || element.element === 'member') {
        return true;
      }

      return false;
    }
  }, {
    key: 'convertKeyToRefract',
    value: function convertKeyToRefract(key, item) {
      var _this4 = this;

      if (this.shouldRefract(item)) {
        return this.serialise(item);
      }

      if (item.element === 'enum') {
        return this.serialiseEnum(item);
      }

      if (item.element === 'array') {
        // This is a plain array, but maybe it contains elements with
        // additional information? Let's see!
        var values = [];

        for (var index = 0; index < item.length; index += 1) {
          var subItem = item.get(index);

          if (this.shouldRefract(subItem) || key === 'default') {
            values.push(this.serialise(subItem));
          } else if (subItem.element === 'array' || subItem.element === 'object' || subItem.element === 'enum') {
            // items for array or enum inside array are always serialised
            var value = subItem.children.map(function (subSubItem) {
              return _this4.serialise(subSubItem);
            });
            values.push(value);
          } else {
            values.push(subItem.toValue());
          }
        }

        return values;
      }

      if (item.element === 'object') {
        // This is an object, so we need to check if it's members contain
        // additional information
        var _values = [];
        var content = item.content || [];

        for (var _index = 0; _index < content.length; _index += 1) {
          _values.push(this.serialise(content[_index]));
        }

        return _values;
      }

      return item.toValue();
    }
  }, {
    key: 'serialiseEnum',
    value: function serialiseEnum(element) {
      var _this5 = this;

      return element.children.map(function (item) {
        return _this5.serialise(item);
      });
    }
  }, {
    key: 'serialiseObject',
    value: function serialiseObject(obj) {
      var _this6 = this;

      var result = {};

      obj.keys().forEach(function (key) {
        var value = obj.get(key);

        if (value) {
          result[key] = _this6.convertKeyToRefract(key, value);
        }
      });

      return result;
    }
  }, {
    key: 'deserialiseObject',
    value: function deserialiseObject(from, to) {
      var _this7 = this;

      Object.keys(from).forEach(function (key) {
        to.set(key, _this7.deserialise(from[key]));
      });
    }
  }]);

  return JSON06Serialiser;
}(JSONSerialiser);

},{"./JSONSerialiser":18}],18:[function(require,module,exports){
'use strict';

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @class JSONSerialiser
 *
 * @param {Namespace} namespace
 *
 * @property {Namespace} namespace
 */
var JSONSerialiser = function () {
  function JSONSerialiser(namespace) {
    _classCallCheck(this, JSONSerialiser);

    this.namespace = namespace || new this.Namespace();
  }

  /**
   * @param {Element} element
   * @returns {object}
   */

  _createClass(JSONSerialiser, [{
    key: 'serialise',
    value: function serialise(element) {
      if (!(element instanceof this.namespace.elements.Element)) {
        throw new TypeError('Given element `' + element + '` is not an Element instance');
      }

      var payload = {
        element: element.element
      };

      if (element._meta && element._meta.length > 0) {
        payload.meta = this.serialiseObject(element.meta);
      }

      if (element._attributes && element._attributes.length > 0) {
        payload.attributes = this.serialiseObject(element.attributes);
      }

      var content = this.serialiseContent(element.content);

      if (content !== undefined) {
        payload.content = content;
      }

      return payload;
    }

    /**
     * @param {object} value
     * @returns {Element}
     */

  }, {
    key: 'deserialise',
    value: function deserialise(value) {
      if (!value.element) {
        throw new Error('Given value is not an object containing an element name');
      }

      var ElementClass = this.namespace.getElementClass(value.element);
      var element = new ElementClass();

      if (element.element !== value.element) {
        element.element = value.element;
      }

      if (value.meta) {
        this.deserialiseObject(value.meta, element.meta);
      }

      if (value.attributes) {
        this.deserialiseObject(value.attributes, element.attributes);
      }

      var content = this.deserialiseContent(value.content);
      if (content !== undefined || element.content === null) {
        element.content = content;
      }

      return element;
    }

    // Private API

  }, {
    key: 'serialiseContent',
    value: function serialiseContent(content) {
      if (content instanceof this.namespace.elements.Element) {
        return this.serialise(content);
      }

      if (content instanceof this.namespace.KeyValuePair) {
        var pair = {
          key: this.serialise(content.key)
        };

        if (content.value) {
          pair.value = this.serialise(content.value);
        }

        return pair;
      }

      if (content && content.map) {
        if (content.length === 0) {
          return undefined;
        }

        return content.map(this.serialise, this);
      }

      return content;
    }
  }, {
    key: 'deserialiseContent',
    value: function deserialiseContent(content) {
      if (content) {
        if (content.element) {
          return this.deserialise(content);
        }

        if (content.key) {
          var pair = new this.namespace.KeyValuePair(this.deserialise(content.key));

          if (content.value) {
            pair.value = this.deserialise(content.value);
          }

          return pair;
        }

        if (content.map) {
          return content.map(this.deserialise, this);
        }
      }

      return content;
    }
  }, {
    key: 'serialiseObject',
    value: function serialiseObject(obj) {
      var _this = this;

      var result = {};

      obj.keys().forEach(function (key) {
        var value = obj.get(key);

        if (value) {
          result[key] = _this.serialise(value);
        }
      });

      return result;
    }
  }, {
    key: 'deserialiseObject',
    value: function deserialiseObject(from, to) {
      var _this2 = this;

      Object.keys(from).forEach(function (key) {
        to.set(key, _this2.deserialise(from[key]));
      });
    }
  }]);

  return JSONSerialiser;
}();

module.exports = JSONSerialiser;

},{}],19:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":54,"./_root":84}],20:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":59,"./_hashDelete":60,"./_hashGet":61,"./_hashHas":62,"./_hashSet":63}],21:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":68,"./_listCacheDelete":69,"./_listCacheGet":70,"./_listCacheHas":71,"./_listCacheSet":72}],22:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":54,"./_root":84}],23:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":73,"./_mapCacheDelete":74,"./_mapCacheGet":75,"./_mapCacheHas":76,"./_mapCacheSet":77}],24:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":54,"./_root":84}],25:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":54,"./_root":84}],26:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":23,"./_setCacheAdd":85,"./_setCacheHas":86}],27:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":21,"./_stackClear":88,"./_stackDelete":89,"./_stackGet":90,"./_stackHas":91,"./_stackSet":92}],28:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":84}],29:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":84}],30:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":54,"./_root":84}],31:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],32:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":44,"./_isIndex":64,"./isArguments":95,"./isArray":96,"./isBuffer":99,"./isTypedArray":108}],33:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],34:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],35:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":94}],36:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":33,"./isArray":96}],37:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":28,"./_getRawTag":55,"./_objectToString":82}],38:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":37,"./isObjectLike":106}],39:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":40,"./isObjectLike":106}],40:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":27,"./_equalArrays":48,"./_equalByTag":49,"./_equalObjects":50,"./_getTag":57,"./isArray":96,"./isBuffer":99,"./isTypedArray":108}],41:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":66,"./_toSource":93,"./isFunction":101,"./isObject":105}],42:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":37,"./isLength":102,"./isObjectLike":106}],43:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":67,"./_nativeKeys":80}],44:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],45:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],46:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],47:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":84}],48:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":26,"./_arraySome":34,"./_cacheHas":46}],49:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":28,"./_Uint8Array":29,"./_equalArrays":48,"./_mapToArray":78,"./_setToArray":87,"./eq":94}],50:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":52}],51:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],52:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":36,"./_getSymbols":56,"./keys":109}],53:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":65}],54:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":41,"./_getValue":58}],55:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":28}],56:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":31,"./stubArray":111}],57:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":19,"./_Map":22,"./_Promise":24,"./_Set":25,"./_WeakMap":30,"./_baseGetTag":37,"./_toSource":93}],58:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],59:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":79}],60:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],61:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":79}],62:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":79}],63:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":79}],64:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],65:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],66:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":47}],67:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],68:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],69:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":35}],70:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":35}],71:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":35}],72:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":35}],73:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":20,"./_ListCache":21,"./_Map":22}],74:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":53}],75:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":53}],76:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":53}],77:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":53}],78:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],79:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":54}],80:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":83}],81:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":51}],82:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],83:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],84:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":51}],85:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],86:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],87:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],88:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":21}],89:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],90:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],91:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],92:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":21,"./_Map":22,"./_MapCache":23}],93:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],94:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],95:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":38,"./isObjectLike":106}],96:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],97:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":101,"./isLength":102}],98:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

module.exports = isBoolean;

},{"./_baseGetTag":37,"./isObjectLike":106}],99:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":84,"./stubFalse":112}],100:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":39}],101:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":37,"./isObject":105}],102:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],103:[function(require,module,exports){
/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

module.exports = isNull;

},{}],104:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":37,"./isObjectLike":106}],105:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],106:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],107:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":37,"./isArray":96,"./isObjectLike":106}],108:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":42,"./_baseUnary":45,"./_nodeUtil":81}],109:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":32,"./_baseKeys":43,"./isArrayLike":97}],110:[function(require,module,exports){
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

module.exports = negate;

},{}],111:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],112:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}]},{},[8])(8)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2xpYi9BcnJheVNsaWNlLmpzIiwiZGlzdC9saWIvS2V5VmFsdWVQYWlyLmpzIiwiZGlzdC9saWIvTmFtZXNwYWNlLmpzIiwiZGlzdC9saWIvT2JqZWN0U2xpY2UuanMiLCJkaXN0L2xpYi9lbGVtZW50cy5qcyIsImRpc3QvbGliL2VsZW1lbnRzL0xpbmtFbGVtZW50LmpzIiwiZGlzdC9saWIvZWxlbWVudHMvUmVmRWxlbWVudC5qcyIsImRpc3QvbGliL21pbmltLmpzIiwiZGlzdC9saWIvcHJpbWl0aXZlcy9BcnJheUVsZW1lbnQuanMiLCJkaXN0L2xpYi9wcmltaXRpdmVzL0Jvb2xlYW5FbGVtZW50LmpzIiwiZGlzdC9saWIvcHJpbWl0aXZlcy9FbGVtZW50LmpzIiwiZGlzdC9saWIvcHJpbWl0aXZlcy9NZW1iZXJFbGVtZW50LmpzIiwiZGlzdC9saWIvcHJpbWl0aXZlcy9OdWxsRWxlbWVudC5qcyIsImRpc3QvbGliL3ByaW1pdGl2ZXMvTnVtYmVyRWxlbWVudC5qcyIsImRpc3QvbGliL3ByaW1pdGl2ZXMvT2JqZWN0RWxlbWVudC5qcyIsImRpc3QvbGliL3ByaW1pdGl2ZXMvU3RyaW5nRWxlbWVudC5qcyIsImRpc3QvbGliL3NlcmlhbGlzZXJzL0pTT04wNlNlcmlhbGlzZXIuanMiLCJkaXN0L2xpYi9zZXJpYWxpc2Vycy9KU09OU2VyaWFsaXNlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc051bGwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9uZWdhdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FBRUEsSUFBSSxlQUFlLFlBQVk7QUFBRSxXQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLEtBQWxDLEVBQXlDO0FBQUUsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFBRSxVQUFJLGFBQWEsTUFBTSxDQUFOLENBQWpCLENBQTJCLFdBQVcsVUFBWCxHQUF3QixXQUFXLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0QsV0FBVyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBVyxVQUFmLEVBQTJCLFdBQVcsUUFBWCxHQUFzQixJQUF0QixDQUE0QixPQUFPLGNBQVAsQ0FBc0IsTUFBdEIsRUFBOEIsV0FBVyxHQUF6QyxFQUE4QyxVQUE5QztBQUE0RDtBQUFFLEdBQUMsT0FBTyxVQUFVLFdBQVYsRUFBdUIsVUFBdkIsRUFBbUMsV0FBbkMsRUFBZ0Q7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbmVnYXRlID0gcmVxdWlyZSgnbG9kYXNoL25lZ2F0ZScpO1xuXG4vLyBDb2VyY2VzIGFuIGEgcGFyYW1ldGVyIGludG8gYSBjYWxsYmFjayBmb3IgbWF0Y2hpbmcgZWxlbWVudHMuXG4vLyBUaGlzIGFjY2VwdHMgYW4gZWxlbWVudCBuYW1lLCBhbiBlbGVtZW50IHR5cGUgYW5kIHJldHVybnMgYVxuLy8gY2FsbGJhY2sgdG8gbWF0Y2ggZm9yIHRob3NlIGVsZW1lbnRzLlxuZnVuY3Rpb24gY29lcmNlRWxlbWVudE1hdGNoaW5nQ2FsbGJhY2sodmFsdWUpIHtcbiAgLy8gRWxlbWVudCBOYW1lXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5lbGVtZW50ID09PSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gRWxlbWVudCBUeXBlXG4gIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5leHRlbmQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHNcbiAqXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gZWxlbWVudHNcbiAqL1xuXG52YXIgQXJyYXlTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXJyYXlTbGljZShlbGVtZW50cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJheVNsaWNlKTtcblxuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEFycmF5U2xpY2UsIFt7XG4gICAga2V5OiAndG9WYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9WYWx1ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGlnaCBPcmRlciBGdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubWFwKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuZCB0aGVuIGZsYXR0ZW5zIHRoZSByZXN1bHRzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIChpLmUgdGhlIHJlZmVyZW5jZSBPYmplY3QpIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge2FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmbGF0TWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGNhbGxiYWNrLCB0aGlzQXJnKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdHJ1dGh5IHJlc3VsdHMgb2YgY2FsbGluZyB0aGUgZ2l2ZW4gdHJhbnNmb3JtYXRpb24gd2l0aCBlYWNoIGVsZW1lbnQgb2YgdGhpcyBzZXF1ZW5jZVxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBIGNsb3N1cmUgdGhhdCBhY2NlcHRzIGFuIGVsZW1lbnQgb2YgdGhpcyBhcnJheSBhcyBpdHMgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gb3B0aW9uYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyAoaS5lIHRoZSByZWZlcmVuY2UgT2JqZWN0KSB3aGVuIGV4ZWN1dGluZyBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBub24tdW5kZWZpbmVkIHJlc3VsdHMgb2YgY2FsbGluZyB0cmFuc2Zvcm0gd2l0aCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhY3RNYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYWN0TWFwKHRyYW5zZm9ybSwgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm0uYmluZCh0aGlzQXJnKShlbGVtZW50KTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuIFRoaXMgbWF5IGJlIGEgY2FsbGJhY2ssIGFuIGVsZW1lbnQgbmFtZSBvciBhbiBlbGVtZW50IGNsYXNzLlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlTbGljZX1cbiAgICAgKiBAbWVtYmVyb2YgQXJyYXlTbGljZS5wcm90b3R5cGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmlsdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGNvZXJjZUVsZW1lbnRNYXRjaGluZ0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlTbGljZSh0aGlzLmVsZW1lbnRzLmZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC4gVGhpcyBtYXkgYmUgYSBjYWxsYmFjaywgYW4gZWxlbWVudCBuYW1lIG9yIGFuIGVsZW1lbnQgY2xhc3MuXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyAoaS5lIHRoZSByZWZlcmVuY2UgT2JqZWN0KSB3aGVuIGV4ZWN1dGluZyBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBcnJheVNsaWNlfVxuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWplY3QoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gY29lcmNlRWxlbWVudE1hdGNoaW5nQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVNsaWNlKHRoaXMuZWxlbWVudHMuZmlsdGVyKG5lZ2F0ZShjYWxsYmFjayksIHRoaXNBcmcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gdmFsdWVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuIFRoaXMgbWF5IGJlIGEgY2FsbGJhY2ssIGFuIGVsZW1lbnQgbmFtZSBvciBhbiBlbGVtZW50IGNsYXNzLlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKiBAbWVtYmVyb2YgQXJyYXlTbGljZS5wcm90b3R5cGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gY29lcmNlRWxlbWVudE1hdGNoaW5nQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZmluZChjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyAoaS5lIHRoZSByZWZlcmVuY2UgT2JqZWN0KSB3aGVuIGV4ZWN1dGluZyBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3JFYWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFZhbHVlXG4gICAgICogQG1lbWJlcm9mIEFycmF5U2xpY2UucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlZHVjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIEFycmF5U2xpY2UucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luY2x1ZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jbHVkZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZXF1YWxzKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE11dGF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIHNsaWNlXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9IFRoZSByZW1vdmVkIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIHRoZSBzbGljZSBpcyBlbXB0eVxuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzaGlmdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBlbGVtZW50IHRvIHRoZSBiZWdpbmluZyBvZiB0aGUgc2xpY2VcbiAgICAgKiBAcGFyYW1ldGVyIHtFbGVtZW50fSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bnNoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2YWx1ZSkge1xuICAgICAgdGhpcy5lbGVtZW50cy51bnNoaWZ0KHRoaXMucmVmcmFjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgc2xpY2VcbiAgICAgKiBAcGFyYW1ldGVyIHtFbGVtZW50fSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2YWx1ZSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKHRoaXMucmVmcmFjdCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtZXRlciB7RWxlbWVudH0gdmFsdWVcbiAgICAgKiBAbWVtYmVyb2YgQXJyYXlTbGljZS5wcm90b3R5cGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFjY2Vzc29yc1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtZXRlciB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJvZiBBcnJheVNsaWNlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW1ldGVyIHtudW1iZXJ9IGluZGV4XG4gICAgICogQG1lbWJlcm9mIEFycmF5U2xpY2UucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoaW5kZXgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpbmRleF07XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnRvVmFsdWUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNsaWNlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzbGljZSBpcyBlbXB0eVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNFbXB0eScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2xpY2Ugb3IgdW5kZWZpbmVkIGlmIHRoZSBzbGljZSBpcyBlbXB0eVxuICAgICAqIEB0eXBlIEVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmlyc3QnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbMF07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFycmF5U2xpY2U7XG59KCk7XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykge1xuICBBcnJheVNsaWNlLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheVNsaWNlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICpcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0ga2V5XG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHZhbHVlXG4gKi9cbnZhciBLZXlWYWx1ZVBhaXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleVZhbHVlUGFpcihrZXksIHZhbHVlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleVZhbHVlUGFpcik7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0tleVZhbHVlUGFpcn1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoS2V5VmFsdWVQYWlyLCBbe1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBLZXlWYWx1ZVBhaXIoKTtcblxuICAgICAgaWYgKHRoaXMua2V5KSB7XG4gICAgICAgIGNsb25lLmtleSA9IHRoaXMua2V5LmNsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIGNsb25lLnZhbHVlID0gdGhpcy52YWx1ZS5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEtleVZhbHVlUGFpcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlWYWx1ZVBhaXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgaXNOdWxsID0gcmVxdWlyZSgnbG9kYXNoL2lzTnVsbCcpO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnbG9kYXNoL2lzU3RyaW5nJyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCdsb2Rhc2gvaXNOdW1iZXInKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCdsb2Rhc2gvaXNCb29sZWFuJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxudmFyIEpTT05TZXJpYWxpc2VyID0gcmVxdWlyZSgnLi9zZXJpYWxpc2Vycy9KU09OU2VyaWFsaXNlcicpO1xudmFyIGVsZW1lbnRzID0gcmVxdWlyZSgnLi9lbGVtZW50cycpO1xuXG4vKipcbiAqIEBjbGFzc1xuICpcbiAqIEEgcmVmcmFjdCBlbGVtZW50IGltcGxlbWVudGF0aW9uIHdpdGggYW4gZXh0ZW5zaWJsZSBuYW1lc3BhY2UsIGFibGUgdG9cbiAqIGxvYWQgb3RoZXIgbmFtZXNwYWNlcyBpbnRvIGl0LlxuICpcbiAqIFRoZSBuYW1lc3BhY2UgYWxsb3dzIHlvdSB0byByZWdpc3RlciB5b3VyIG93biBjbGFzc2VzIHRvIGJlIGluc3RhbnRpYXRlZFxuICogd2hlbiBhIHBhcnRpY3VsYXIgcmVmcmFjdCBlbGVtZW50IGlzIGVuY291bnRlcmVkLCBhbmQgYWxsb3dzIHlvdSB0byBzcGVjaWZ5XG4gKiB3aGljaCBlbGVtZW50cyBnZXQgaW5zdGFudGlhdGVkIGZvciBleGlzdGluZyBKYXZhc2NyaXB0IG9iamVjdHMuXG4gKi9cblxudmFyIE5hbWVzcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTmFtZXNwYWNlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmFtZXNwYWNlKTtcblxuICAgIHRoaXMuZWxlbWVudE1hcCA9IHt9O1xuICAgIHRoaXMuZWxlbWVudERldGVjdGlvbiA9IFtdO1xuICAgIHRoaXMuRWxlbWVudCA9IGVsZW1lbnRzLkVsZW1lbnQ7XG4gICAgdGhpcy5LZXlWYWx1ZVBhaXIgPSBlbGVtZW50cy5LZXlWYWx1ZVBhaXI7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9EZWZhdWx0KSB7XG4gICAgICB0aGlzLnVzZURlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcm92aWRlIHRoZSBkZWZhdWx0cyBmb3IgbmV3IGVsZW1lbnRzLlxuICAgIHRoaXMuX2F0dHJpYnV0ZUVsZW1lbnRLZXlzID0gW107XG4gICAgdGhpcy5fYXR0cmlidXRlRWxlbWVudEFycmF5S2V5cyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBhIG5hbWVzcGFjZSBwbHVnaW4gb3IgbG9hZCBhIGdlbmVyaWMgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gcGx1Z2luXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5hbWVzcGFjZSwgW3tcbiAgICBrZXk6ICd1c2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1c2UocGx1Z2luKSB7XG4gICAgICBpZiAocGx1Z2luLm5hbWVzcGFjZSkge1xuICAgICAgICBwbHVnaW4ubmFtZXNwYWNlKHsgYmFzZTogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwbHVnaW4ubG9hZCkge1xuICAgICAgICBwbHVnaW4ubG9hZCh7IGJhc2U6IHRoaXMgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFVzZSB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuIFRoaXMgcHJlbG9hZHMgYWxsIHRoZSBkZWZhdWx0IGVsZW1lbnRzXG4gICAgICogaW50byB0aGlzIHJlZ2lzdHJ5IGluc3RhbmNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1c2VEZWZhdWx0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXNlRGVmYXVsdCgpIHtcbiAgICAgIC8vIFNldCB1cCBjbGFzc2VzIGZvciBkZWZhdWx0IGVsZW1lbnRzXG4gICAgICB0aGlzLnJlZ2lzdGVyKCdudWxsJywgZWxlbWVudHMuTnVsbEVsZW1lbnQpLnJlZ2lzdGVyKCdzdHJpbmcnLCBlbGVtZW50cy5TdHJpbmdFbGVtZW50KS5yZWdpc3RlcignbnVtYmVyJywgZWxlbWVudHMuTnVtYmVyRWxlbWVudCkucmVnaXN0ZXIoJ2Jvb2xlYW4nLCBlbGVtZW50cy5Cb29sZWFuRWxlbWVudCkucmVnaXN0ZXIoJ2FycmF5JywgZWxlbWVudHMuQXJyYXlFbGVtZW50KS5yZWdpc3Rlcignb2JqZWN0JywgZWxlbWVudHMuT2JqZWN0RWxlbWVudCkucmVnaXN0ZXIoJ21lbWJlcicsIGVsZW1lbnRzLk1lbWJlckVsZW1lbnQpLnJlZ2lzdGVyKCdyZWYnLCBlbGVtZW50cy5SZWZFbGVtZW50KS5yZWdpc3RlcignbGluaycsIGVsZW1lbnRzLkxpbmtFbGVtZW50KTtcblxuICAgICAgLy8gQWRkIGluc3RhbmNlIGRldGVjdGlvbiBmdW5jdGlvbnMgdG8gY29udmVydCBleGlzdGluZyBvYmplY3RzIGludG9cbiAgICAgIC8vIHRoZSBjb3JyZXNwb25kaW5nIHJlZnJhY3QgZWxlbWVudHMuXG4gICAgICB0aGlzLmRldGVjdChpc051bGwsIGVsZW1lbnRzLk51bGxFbGVtZW50LCBmYWxzZSkuZGV0ZWN0KGlzU3RyaW5nLCBlbGVtZW50cy5TdHJpbmdFbGVtZW50LCBmYWxzZSkuZGV0ZWN0KGlzTnVtYmVyLCBlbGVtZW50cy5OdW1iZXJFbGVtZW50LCBmYWxzZSkuZGV0ZWN0KGlzQm9vbGVhbiwgZWxlbWVudHMuQm9vbGVhbkVsZW1lbnQsIGZhbHNlKS5kZXRlY3QoQXJyYXkuaXNBcnJheSwgZWxlbWVudHMuQXJyYXlFbGVtZW50LCBmYWxzZSkuZGV0ZWN0KGlzT2JqZWN0LCBlbGVtZW50cy5PYmplY3RFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IGVsZW1lbnQgY2xhc3MgZm9yIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSBlbGVtZW50Q2xhc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBFbGVtZW50Q2xhc3MpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5lbGVtZW50TWFwW25hbWVdID0gRWxlbWVudENsYXNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjbGFzcyBmb3IgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgZGVsZXRlIHRoaXMuZWxlbWVudE1hcFtuYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQWRkIGEgbmV3IGRldGVjdGlvbiBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggZWxlbWVudFxuICAgICAqIGNsYXNzIHRvIHVzZSB3aGVuIGNvbnZlcnRpbmcgZXhpc3RpbmcganMgaW5zdGFuY2VzIGludG9cbiAgICAgKiByZWZyYWN0IGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RldGVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVjdCh0ZXN0LCBFbGVtZW50Q2xhc3MsIGdpdmVuUHJlcGVuZCkge1xuICAgICAgdmFyIHByZXBlbmQgPSBnaXZlblByZXBlbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBnaXZlblByZXBlbmQ7XG5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudERldGVjdGlvbi51bnNoaWZ0KFt0ZXN0LCBFbGVtZW50Q2xhc3NdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudERldGVjdGlvbi5wdXNoKFt0ZXN0LCBFbGVtZW50Q2xhc3NdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGFuIGV4aXN0aW5nIEphdmFzY3JpcHQgb2JqZWN0IGludG8gcmVmcmFjdCBlbGVtZW50IGluc3RhbmNlcywgd2hpY2hcbiAgICAgKiBjYW4gYmUgZnVydGhlciBwcm9jZXNzZWQgb3Igc2VyaWFsaXplZCBpbnRvIHJlZnJhY3QuXG4gICAgICogSWYgdGhlIGl0ZW0gcGFzc2VkIGluIGlzIGFscmVhZHkgcmVmcmFjdGVkLCB0aGVuIGl0IGlzIHJldHVybmVkXG4gICAgICogdW5tb2RpZmllZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9FbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9FbGVtZW50KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzLkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnREZXRlY3Rpb24ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRlc3QgPSB0aGlzLmVsZW1lbnREZXRlY3Rpb25baV1bMF07XG4gICAgICAgIHZhciBFbGVtZW50Q2xhc3MgPSB0aGlzLmVsZW1lbnREZXRlY3Rpb25baV1bMV07XG5cbiAgICAgICAgaWYgKHRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50Q2xhc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogR2V0IGFuIGVsZW1lbnQgY2xhc3MgZ2l2ZW4gYW4gZWxlbWVudCBuYW1lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRFbGVtZW50Q2xhc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoZWxlbWVudCkge1xuICAgICAgdmFyIEVsZW1lbnRDbGFzcyA9IHRoaXMuZWxlbWVudE1hcFtlbGVtZW50XTtcblxuICAgICAgaWYgKEVsZW1lbnRDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgYmFzZSBlbGVtZW50LiBXZSBtYXkgbm90IGtub3cgd2hhdFxuICAgICAgICAvLyB0byBkbyB3aXRoIHRoZSBgY29udGVudGAsIGJ1dCBkb3duc3RyZWFtIHNvZnR3YXJlXG4gICAgICAgIC8vIG1heSBrbm93LlxuICAgICAgICByZXR1cm4gdGhpcy5FbGVtZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRWxlbWVudENsYXNzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29udmVydCBhIHJlZnJhY3QgZG9jdW1lbnQgaW50byByZWZyYWN0IGVsZW1lbnQgaW5zdGFuY2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tUmVmcmFjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SZWZyYWN0KGRvYykge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXNlci5kZXNlcmlhbGlzZShkb2MpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29udmVydCBhbiBlbGVtZW50IHRvIGEgUmVmcmFjdGVkIEpTT04gb2JqZWN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1JlZnJhY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1JlZnJhY3QoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXNlci5zZXJpYWxpc2UoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgZWxlbWVudCBjbGFzc2VzLCB3aGVyZVxuICAgICAqIHRoZSBrZXkgaXMgdGhlIFBhc2NhbENhc2VkIGVsZW1lbnQgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjbGFzcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWxlbWVudHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSB7XG4gICAgICAgICAgRWxlbWVudDogdGhpcy5FbGVtZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5lbGVtZW50TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgLy8gQ3VycmVudGx5LCBhbGwgcmVnaXN0ZXJlZCBlbGVtZW50IHR5cGVzIHVzZSBhIGNhbWVsQ2FzZU5hbWUuXG4gICAgICAgICAgLy8gQ29udmVydGluZyB0byBQYXNjYWxDYXNlIGlzIGFzIHNpbXBsZSBhcyB1cHBlci1jYXNpbmcgdGhlIGZpcnN0XG4gICAgICAgICAgLy8gbGV0dGVyLlxuICAgICAgICAgIHZhciBwYXNjYWwgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICBfdGhpcy5fZWxlbWVudHNbcGFzY2FsXSA9IF90aGlzLmVsZW1lbnRNYXBbbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmluaWVuY2UgbWV0aG9kIGZvciBnZXR0aW5nIGEgSlNPTiBTZXJpYWxpc2VyIGNvbmZpZ3VyZWQgd2l0aCB0aGVcbiAgICAgKiBjdXJyZW50IG5hbWVzcGFjZVxuICAgICAqXG4gICAgICogQHR5cGUgSlNPTlNlcmlhbGlzZXJcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBOYW1lc3BhY2UucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlcmlhbGlzZXInLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBKU09OU2VyaWFsaXNlcih0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmFtZXNwYWNlO1xufSgpO1xuXG5KU09OU2VyaWFsaXNlci5wcm90b3R5cGUuTmFtZXNwYWNlID0gTmFtZXNwYWNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hbWVzcGFjZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIG5lZ2F0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9uZWdhdGUnKTtcbnZhciBBcnJheVNsaWNlID0gcmVxdWlyZSgnLi9BcnJheVNsaWNlJyk7XG5cbi8qKlxuICovXG5cbnZhciBPYmplY3RTbGljZSA9IGZ1bmN0aW9uIChfQXJyYXlTbGljZSkge1xuICBfaW5oZXJpdHMoT2JqZWN0U2xpY2UsIF9BcnJheVNsaWNlKTtcblxuICBmdW5jdGlvbiBPYmplY3RTbGljZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0U2xpY2UpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPYmplY3RTbGljZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdFNsaWNlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0U2xpY2UsIFt7XG4gICAga2V5OiAnbWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYmluZCh0aGlzQXJnKShtZW1iZXIudmFsdWUsIG1lbWJlci5rZXksIG1lbWJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWx0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBuZXcgT2JqZWN0U2xpY2UodGhpcy5lbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYmluZCh0aGlzQXJnKShtZW1iZXIudmFsdWUsIG1lbWJlci5rZXksIG1lbWJlcik7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVqZWN0KGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGNhbGxiYWNrLmJpbmQodGhpc0FyZykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JFYWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVyLCBpbmRleCkge1xuICAgICAgICBjYWxsYmFjay5iaW5kKHRoaXNBcmcpKG1lbWJlci52YWx1ZSwgbWVtYmVyLmtleSwgbWVtYmVyLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2tleXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkudG9WYWx1ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1ZhbHVlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JqZWN0U2xpY2U7XG59KEFycmF5U2xpY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdFNsaWNlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9FbGVtZW50Jyk7XG52YXIgTnVsbEVsZW1lbnQgPSByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvTnVsbEVsZW1lbnQnKTtcbnZhciBTdHJpbmdFbGVtZW50ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL1N0cmluZ0VsZW1lbnQnKTtcbnZhciBOdW1iZXJFbGVtZW50ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL051bWJlckVsZW1lbnQnKTtcbnZhciBCb29sZWFuRWxlbWVudCA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9Cb29sZWFuRWxlbWVudCcpO1xudmFyIEFycmF5RWxlbWVudCA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9BcnJheUVsZW1lbnQnKTtcbnZhciBNZW1iZXJFbGVtZW50ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL01lbWJlckVsZW1lbnQnKTtcbnZhciBPYmplY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL09iamVjdEVsZW1lbnQnKTtcbnZhciBMaW5rRWxlbWVudCA9IHJlcXVpcmUoJy4vZWxlbWVudHMvTGlua0VsZW1lbnQnKTtcbnZhciBSZWZFbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50cy9SZWZFbGVtZW50Jyk7XG5cbnZhciBBcnJheVNsaWNlID0gcmVxdWlyZSgnLi9BcnJheVNsaWNlJyk7XG52YXIgT2JqZWN0U2xpY2UgPSByZXF1aXJlKCcuL09iamVjdFNsaWNlJyk7XG5cbnZhciBLZXlWYWx1ZVBhaXIgPSByZXF1aXJlKCcuL0tleVZhbHVlUGFpcicpO1xuXG4vKipcbiAqIFJlZnJhY3RzIGEgSlNPTiB0eXBlIHRvIG1pbmltIGVsZW1lbnRzXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiByZWZyYWN0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgU3RyaW5nRWxlbWVudCh2YWx1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgTnVtYmVyRWxlbWVudCh2YWx1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5FbGVtZW50KHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgTnVsbEVsZW1lbnQoKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlFbGVtZW50KHZhbHVlLm1hcChyZWZyYWN0KSk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5ldyBPYmplY3RFbGVtZW50KHZhbHVlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuRWxlbWVudC5wcm90b3R5cGUuT2JqZWN0RWxlbWVudCA9IE9iamVjdEVsZW1lbnQ7XG5FbGVtZW50LnByb3RvdHlwZS5SZWZFbGVtZW50ID0gUmVmRWxlbWVudDtcbkVsZW1lbnQucHJvdG90eXBlLk1lbWJlckVsZW1lbnQgPSBNZW1iZXJFbGVtZW50O1xuXG5FbGVtZW50LnByb3RvdHlwZS5yZWZyYWN0ID0gcmVmcmFjdDtcbkFycmF5U2xpY2UucHJvdG90eXBlLnJlZnJhY3QgPSByZWZyYWN0O1xuXG4vKipcbiAqIENvbnRhaW5zIGFsbCBvZiB0aGUgZWxlbWVudCBjbGFzc2VzLCBhbmQgcmVsYXRlZCBzdHJ1Y3R1cmVzIGFuZCBtZXRob2RzXG4gKiBmb3IgaGFuZGxpbmcgd2l0aCBlbGVtZW50IGluc3RhbmNlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVsZW1lbnQ6IEVsZW1lbnQsXG4gIE51bGxFbGVtZW50OiBOdWxsRWxlbWVudCxcbiAgU3RyaW5nRWxlbWVudDogU3RyaW5nRWxlbWVudCxcbiAgTnVtYmVyRWxlbWVudDogTnVtYmVyRWxlbWVudCxcbiAgQm9vbGVhbkVsZW1lbnQ6IEJvb2xlYW5FbGVtZW50LFxuICBBcnJheUVsZW1lbnQ6IEFycmF5RWxlbWVudCxcbiAgTWVtYmVyRWxlbWVudDogTWVtYmVyRWxlbWVudCxcbiAgT2JqZWN0RWxlbWVudDogT2JqZWN0RWxlbWVudCxcbiAgTGlua0VsZW1lbnQ6IExpbmtFbGVtZW50LFxuICBSZWZFbGVtZW50OiBSZWZFbGVtZW50LFxuXG4gIHJlZnJhY3Q6IHJlZnJhY3QsXG5cbiAgQXJyYXlTbGljZTogQXJyYXlTbGljZSxcbiAgT2JqZWN0U2xpY2U6IE9iamVjdFNsaWNlLFxuICBLZXlWYWx1ZVBhaXI6IEtleVZhbHVlUGFpclxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9wcmltaXRpdmVzL0VsZW1lbnQnKTtcblxuLyoqIEh5cGVybGlua2luZyBNQVkgYmUgdXNlZCB0byBsaW5rIHRvIG90aGVyIHJlc291cmNlcywgcHJvdmlkZSBsaW5rcyB0b1xuICogaW5zdHJ1Y3Rpb25zIG9uIGhvdyB0byBwcm9jZXNzIGEgZ2l2ZW4gZWxlbWVudCAoYnkgd2F5IG9mIGEgcHJvZmlsZSBvclxuICogb3RoZXIgbWVhbnMpLCBhbmQgbWF5IGJlIHVzZWQgdG8gcHJvdmlkZSBtZXRhIGRhdGEgYWJvdXQgdGhlIGVsZW1lbnQgaW5cbiAqIHdoaWNoIGl0J3MgZm91bmQuIFRoZSBtZWFuaW5nIGFuZCBwdXJwb3NlIG9mIHRoZSBoeXBlcmxpbmsgaXMgZGVmaW5lZCBieVxuICogdGhlIGxpbmsgcmVsYXRpb24gYWNjb3JkaW5nIHRvIFJGQyA1OTg4LlxuICpcbiAqIEBjbGFzcyBMaW5rRWxlbWVudFxuICpcbiAqIEBwYXJhbSBjb250ZW50XG4gKiBAcGFyYW0gbWV0YVxuICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzKExpbmtFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gTGlua0VsZW1lbnQoY29udGVudCwgbWV0YSwgYXR0cmlidXRlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGlua0VsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5rRWxlbWVudCkpLmNhbGwodGhpcywgY29udGVudCB8fCBbXSwgbWV0YSwgYXR0cmlidXRlcykpO1xuXG4gICAgX3RoaXMuZWxlbWVudCA9ICdsaW5rJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlbGF0aW9uIGlkZW50aWZpZXIgZm9yIHRoZSBsaW5rLCBhcyBkZWZpbmVkIGluIFJGQyA1OTg4LlxuICAgKiBAdHlwZSBTdHJpbmdFbGVtZW50XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExpbmtFbGVtZW50LCBbe1xuICAgIGtleTogJ3JlbGF0aW9uJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0KCdyZWxhdGlvbicpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocmVsYXRpb24pIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zZXQoJ3JlbGF0aW9uJywgcmVsYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBVUkkgZm9yIHRoZSBnaXZlbiBsaW5rLlxuICAgICAqIEB0eXBlIFN0cmluZ0VsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaHJlZicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldCgnaHJlZicpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoaHJlZikge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLnNldCgnaHJlZicsIGhyZWYpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5rRWxlbWVudDtcbn0oRWxlbWVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vcHJpbWl0aXZlcy9FbGVtZW50Jyk7XG5cbi8qKlxuICogQGNsYXNzIFJlZkVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gY29udGVudFxuICogQHBhcmFtIG1ldGFcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHMoUmVmRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZkVsZW1lbnQoY29udGVudCwgbWV0YSwgYXR0cmlidXRlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWZFbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChSZWZFbGVtZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmVmRWxlbWVudCkpLmNhbGwodGhpcywgY29udGVudCB8fCBbXSwgbWV0YSwgYXR0cmlidXRlcykpO1xuXG4gICAgX3RoaXMuZWxlbWVudCA9ICdyZWYnO1xuXG4gICAgaWYgKCFfdGhpcy5wYXRoKSB7XG4gICAgICBfdGhpcy5wYXRoID0gJ2VsZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGF0aCBvZiByZWZlcmVuY2VkIGVsZW1lbnQgdG8gdHJhbnNjbHVkZSBpbnN0ZWFkIG9mIGVsZW1lbnQgaXRzZWxmLlxuICAgKiBAdHlwZSBTdHJpbmdFbGVtZW50XG4gICAqIEBkZWZhdWx0IGVsZW1lbnRcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUmVmRWxlbWVudCwgW3tcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0KCdwYXRoJyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLnNldCgncGF0aCcsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVmRWxlbWVudDtcbn0oRWxlbWVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZSgnLi9OYW1lc3BhY2UnKTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoJy4vZWxlbWVudHMnKTtcblxuLy8gRGlyZWN0IGFjY2VzcyB0byB0aGUgTmFtZXNwYWNlIGNsYXNzXG5leHBvcnRzLk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcblxuLy8gU3BlY2lhbCBjb25zdHJ1Y3RvciBmb3IgdGhlIE5hbWVzcGFjZSBjbGFzc1xuZXhwb3J0cy5uYW1lc3BhY2UgPSBmdW5jdGlvbiBuYW1lc3BhY2Uob3B0aW9ucykge1xuICByZXR1cm4gbmV3IE5hbWVzcGFjZShvcHRpb25zKTtcbn07XG5cbmV4cG9ydHMuS2V5VmFsdWVQYWlyID0gcmVxdWlyZSgnLi9LZXlWYWx1ZVBhaXInKTtcblxuZXhwb3J0cy5BcnJheVNsaWNlID0gZWxlbWVudHMuQXJyYXlTbGljZTtcbmV4cG9ydHMuT2JqZWN0U2xpY2UgPSBlbGVtZW50cy5PYmplY3RTbGljZTtcblxuZXhwb3J0cy5FbGVtZW50ID0gZWxlbWVudHMuRWxlbWVudDtcbmV4cG9ydHMuU3RyaW5nRWxlbWVudCA9IGVsZW1lbnRzLlN0cmluZ0VsZW1lbnQ7XG5leHBvcnRzLk51bWJlckVsZW1lbnQgPSBlbGVtZW50cy5OdW1iZXJFbGVtZW50O1xuZXhwb3J0cy5Cb29sZWFuRWxlbWVudCA9IGVsZW1lbnRzLkJvb2xlYW5FbGVtZW50O1xuZXhwb3J0cy5OdWxsRWxlbWVudCA9IGVsZW1lbnRzLk51bGxFbGVtZW50O1xuZXhwb3J0cy5BcnJheUVsZW1lbnQgPSBlbGVtZW50cy5BcnJheUVsZW1lbnQ7XG5leHBvcnRzLk9iamVjdEVsZW1lbnQgPSBlbGVtZW50cy5PYmplY3RFbGVtZW50O1xuZXhwb3J0cy5NZW1iZXJFbGVtZW50ID0gZWxlbWVudHMuTWVtYmVyRWxlbWVudDtcbmV4cG9ydHMuUmVmRWxlbWVudCA9IGVsZW1lbnRzLlJlZkVsZW1lbnQ7XG5leHBvcnRzLkxpbmtFbGVtZW50ID0gZWxlbWVudHMuTGlua0VsZW1lbnQ7XG5cbmV4cG9ydHMucmVmcmFjdCA9IGVsZW1lbnRzLnJlZnJhY3Q7XG5cbmV4cG9ydHMuSlNPTlNlcmlhbGlzZXIgPSByZXF1aXJlKCcuL3NlcmlhbGlzZXJzL0pTT05TZXJpYWxpc2VyJyk7XG5leHBvcnRzLkpTT04wNlNlcmlhbGlzZXIgPSByZXF1aXJlKCcuL3NlcmlhbGlzZXJzL0pTT04wNlNlcmlhbGlzZXInKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIG5lZ2F0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9uZWdhdGUnKTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9FbGVtZW50Jyk7XG52YXIgQXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL0FycmF5U2xpY2UnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gY29udGVudFxuICogQHBhcmFtIG1ldGFcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gKi9cblxudmFyIEFycmF5RWxlbWVudCA9IGZ1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHMoQXJyYXlFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQXJyYXlFbGVtZW50KGNvbnRlbnQsIG1ldGEsIGF0dHJpYnV0ZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyYXlFbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBcnJheUVsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBcnJheUVsZW1lbnQpKS5jYWxsKHRoaXMsIGNvbnRlbnQgfHwgW10sIG1ldGEsIGF0dHJpYnV0ZXMpKTtcblxuICAgIF90aGlzLmVsZW1lbnQgPSAnYXJyYXknO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBcnJheUVsZW1lbnQsIFt7XG4gICAga2V5OiAncHJpbWl0aXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbWl0aXZlKCkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciByZXR1cm5pbmcgdGhlIHZhbHVlIG9mIGFuIGl0ZW1cbiAgICAgKiBUaGlzIHdvcmtzIGZvciBib3RoIEFycmF5RWxlbWVudCBhbmQgT2JqZWN0RWxlbWVudCBpbnN0YW5jZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShpbmRleE9yS2V5KSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0KGluZGV4T3JLZXkpO1xuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b1ZhbHVlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY29udGVudFtpbmRleF0gPSB0aGlzLnJlZnJhY3QodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGluZGV4KSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuY29udGVudC5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWRbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lm1hcChjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhbmQgdGhlbiBmbGF0dGVucyB0aGUgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyAoaS5lIHRoZSByZWZlcmVuY2UgT2JqZWN0KSB3aGVuIGV4ZWN1dGluZyBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHthcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmxhdE1hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXRNYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChjYWxsYmFjaywgdGhpc0FyZykucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRydXRoeSByZXN1bHRzIG9mIGNhbGxpbmcgdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIHdpdGggZWFjaCBlbGVtZW50IG9mIHRoaXMgc2VxdWVuY2VcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQSBjbG9zdXJlIHRoYXQgYWNjZXB0cyBhbiBlbGVtZW50IG9mIHRoaXMgYXJyYXkgYXMgaXRzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIG9wdGlvbmFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyb2YgQXJyYXlFbGVtZW50LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBub24tdW5kZWZpbmVkIHJlc3VsdHMgb2YgY2FsbGluZyB0cmFuc2Zvcm0gd2l0aCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhY3RNYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYWN0TWFwKHRyYW5zZm9ybSwgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm0uYmluZCh0aGlzQXJnKShlbGVtZW50KTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIChpLmUgdGhlIHJlZmVyZW5jZSBPYmplY3QpIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0FycmF5U2xpY2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVNsaWNlKHRoaXMuY29udGVudC5maWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIChpLmUgdGhlIHJlZmVyZW5jZSBPYmplY3QpIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0FycmF5U2xpY2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlamVjdChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShjYWxsYmFjayksIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSByZWR1Y2UgZnVuY3Rpb24gc3BlY2lmaWNhbGx5IGZvciBNaW5pbSBhcnJheXMgYW5kIG9iamVjdHMuIEl0XG4gICAgICogYWxsb3dzIGZvciByZXR1cm5pbmcgbm9ybWFsIHZhbHVlcyBvciBNaW5pbSBpbnN0YW5jZXMsIHNvIGl0IGNvbnZlcnRzIGFueVxuICAgICAqIHByaW1pdGl2ZXMgb24gZWFjaCBzdGVwLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWR1Y2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSB2b2lkIDA7XG4gICAgICB2YXIgbWVtbyA9IHZvaWQgMDtcblxuICAgICAgLy8gQWxsb3dzIGZvciBkZWZpbmluZyBhIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSByZWR1Y2VcbiAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgbWVtbyA9IHRoaXMucmVmcmFjdChpbml0aWFsVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IDE7XG4gICAgICAgIC8vIE9iamVjdCBFbGVtZW50IGNvbnRlbnQgaXRlbXMgYXJlIG1lbWJlciBlbGVtZW50cy4gQmVjYXVzZSBvZiB0aGlzLFxuICAgICAgICAvLyB0aGUgbWVtbyBzaG91bGQgc3RhcnQgb3V0IGFzIHRoZSBtZW1iZXIgdmFsdWUgcmF0aGVyIHRoYW4gdGhlXG4gICAgICAgIC8vIGFjdHVhbCBtZW1iZXIgaXRzZWxmLlxuICAgICAgICBtZW1vID0gdGhpcy5wcmltaXRpdmUoKSA9PT0gJ29iamVjdCcgPyB0aGlzLmZpcnN0LnZhbHVlIDogdGhpcy5maXJzdDtcbiAgICAgIH1cblxuICAgICAgLy8gU2VuZGluZyBlYWNoIGZ1bmN0aW9uIGNhbGwgdG8gdGhlIHJlZ2lzdHJ5IGFsbG93cyBmb3IgcGFzc2luZyBNaW5pbVxuICAgICAgLy8gaW5zdGFuY2VzIHRocm91Z2ggdGhlIGZ1bmN0aW9uIHJldHVybi4gVGhpcyBtZWFucyB5b3UgY2FuIHJldHVyblxuICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlcyBvciByZXR1cm4gTWluaW0gaW5zdGFuY2VzIGFuZCByZWR1Y2Ugd2lsbCBzdGlsbCB3b3JrLlxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5jb250ZW50W2ldO1xuXG4gICAgICAgIGlmICh0aGlzLnByaW1pdGl2ZSgpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG1lbW8gPSB0aGlzLnJlZnJhY3QoY2FsbGJhY2sobWVtbywgaXRlbS52YWx1ZSwgaXRlbS5rZXksIGl0ZW0sIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW1vID0gdGhpcy5yZWZyYWN0KGNhbGxiYWNrKG1lbW8sIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2FsbGJhY2sgZm9yRWFjaENhbGxiYWNrXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjdXJyZW50VmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlckVsZW1lbnR9IGluZGV4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ZvckVhY2hDYWxsYmFja30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIChpLmUgdGhlIHJlZmVyZW5jZSBPYmplY3QpIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrXG4gICAgICogQG1lbWJlcm9mIEFycmF5RWxlbWVudC5wcm90b3R5cGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZm9yRWFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suYmluZCh0aGlzQXJnKShpdGVtLCBfdGhpczIucmVmcmFjdChpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vuc2hpZnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbnRlbnQudW5zaGlmdCh0aGlzLnJlZnJhY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godmFsdWUpIHtcbiAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMucmVmcmFjdCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1c2l2ZWx5IHNlYXJjaCBhbGwgZGVzY2VuZGVudHMgdXNpbmcgYSBjb25kaXRpb24gZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZEVsZW1lbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbmRpdGlvbiwgZ2l2ZW5PcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGdpdmVuT3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciByZWN1cnNpdmUgPSAhIW9wdGlvbnMucmVjdXJzaXZlO1xuICAgICAgdmFyIHJlc3VsdHMgPSBvcHRpb25zLnJlc3VsdHMgPT09IHVuZGVmaW5lZCA/IFtdIDogb3B0aW9ucy5yZXN1bHRzO1xuXG4gICAgICAvLyBUaGUgZm9yRWFjaCBtZXRob2QgZm9yIE9iamVjdCBFbGVtZW50cyByZXR1cm5zIHZhbHVlLCBrZXksIGFuZCBtZW1iZXIuXG4gICAgICAvLyBUaGlzIHBhc3NlcyB0aG9zZSBhbG9uZyB0byB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIGJlbG93LlxuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBrZXlPckluZGV4LCBtZW1iZXIpIHtcbiAgICAgICAgLy8gV2UgdXNlIGR1Y2stdHlwaW5nIGhlcmUgdG8gc3VwcG9ydCBhbnkgcmVnaXN0ZXJlZCBjbGFzcyB0aGF0XG4gICAgICAgIC8vIG1heSBjb250YWluIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICBpZiAocmVjdXJzaXZlICYmIGl0ZW0uZmluZEVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVtLmZpbmRFbGVtZW50cyhjb25kaXRpb24sIHtcbiAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgICAgICByZWN1cnNpdmU6IHJlY3Vyc2l2ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbihpdGVtLCBrZXlPckluZGV4LCBtZW1iZXIpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXNpdmVseSBzZWFyY2ggYWxsIGRlc2NlbmRlbnRzIHVzaW5nIGEgY29uZGl0aW9uIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBjb25kaXRpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlTbGljZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5U2xpY2UodGhpcy5maW5kRWxlbWVudHMoY29uZGl0aW9uLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlTbGljZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZEJ5RWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCeUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgICAqIEByZXR1cm5zIHtBcnJheVNsaWNlfVxuICAgICAqIEBtZW1iZXJvZiBBcnJheUVsZW1lbnQucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmRCeUNsYXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJ5Q2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmNsYXNzZXMuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgdHJlZSByZWN1cnNpdmVseSBhbmQgZmluZCB0aGUgZWxlbWVudCB3aXRoIHRoZSBtYXRjaGluZyBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJvZiBBcnJheUVsZW1lbnQucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEJ5SWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlkLnRvVmFsdWUoKSA9PT0gaWQ7XG4gICAgICB9KS5maXJzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb29rcyBmb3IgbWF0Y2hpbmcgY2hpbGRyZW4gdXNpbmcgZGVlcCBlcXVhbGl0eVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb250YWlucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZXF1YWxzKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZhbnRhc3kgTGFuZFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5RWxlbWVudH0gQW4gZW1wdHkgYXJyYXkgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbXB0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmYW50YXN5LWxhbmQvZW1wdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYW50YXN5TGFuZEVtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1wdHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5RWxlbWVudH0gb3RoZXJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlFbGVtZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb25jYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQob3RoZXIpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmNvbnRlbnQuY29uY2F0KG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmYW50YXN5LWxhbmQvY29uY2F0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFudGFzeUxhbmRDb25jYXQob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmNhdChvdGhlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmFudGFzeS1sYW5kL21hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhbnRhc3lMYW5kTWFwKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubWFwKHRyYW5zZm9ybSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZhbnRhc3ktbGFuZC9jaGFpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhbnRhc3lMYW5kQ2hhaW4odHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShlbGVtZW50KTtcbiAgICAgIH0sIHRoaXMpLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9LCB0aGlzLmVtcHR5KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZhbnRhc3ktbGFuZC9maWx0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYW50YXN5TGFuZEZpbHRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuY29udGVudC5maWx0ZXIoY2FsbGJhY2spKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmYW50YXN5LWxhbmQvcmVkdWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFudGFzeUxhbmRSZWR1Y2UodHJhbnNmb3JtLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQucmVkdWNlKHRyYW5zZm9ybSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNFbXB0eScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAdHlwZSBFbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpcnN0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc2Vjb25kIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAdHlwZSBFbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlY29uZCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmRleCgxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxhc3QgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIEB0eXBlIEVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGFzdCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmRleCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBcnJheUVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtBcnJheUVsZW1lbnR9IEFuIGVtcHR5IGFycmF5IGVsZW1lbnRcbiAqL1xuXG5cbkFycmF5RWxlbWVudC5lbXB0eSA9IGZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gbmV3IHRoaXMoKTtcbn07XG5cbkFycmF5RWxlbWVudFsnZmFudGFzeS1sYW5kL2VtcHR5J10gPSBBcnJheUVsZW1lbnQuZW1wdHk7XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykge1xuICBBcnJheUVsZW1lbnQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlFbGVtZW50OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xuXG4vKipcbiAqIEBjbGFzcyBCb29sZWFuRWxlbWVudFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29udGVudFxuICogQHBhcmFtIG1ldGFcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0cyhCb29sZWFuRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEJvb2xlYW5FbGVtZW50KGNvbnRlbnQsIG1ldGEsIGF0dHJpYnV0ZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9vbGVhbkVsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJvb2xlYW5FbGVtZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkVsZW1lbnQpKS5jYWxsKHRoaXMsIGNvbnRlbnQsIG1ldGEsIGF0dHJpYnV0ZXMpKTtcblxuICAgIF90aGlzLmVsZW1lbnQgPSAnYm9vbGVhbic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJvb2xlYW5FbGVtZW50LCBbe1xuICAgIGtleTogJ3ByaW1pdGl2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW1pdGl2ZSgpIHtcbiAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJvb2xlYW5FbGVtZW50O1xufShFbGVtZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGlzRXF1YWwgPSByZXF1aXJlKCdsb2Rhc2gvaXNFcXVhbCcpO1xudmFyIEtleVZhbHVlUGFpciA9IHJlcXVpcmUoJy4uL0tleVZhbHVlUGFpcicpO1xudmFyIEFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9BcnJheVNsaWNlLmpzJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIGNvbnRlbnRcbiAqIEBwYXJhbSBtZXRhXG4gKiBAcGFyYW0gYXR0cmlidXRlc1xuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbGVtZW50XG4gKi9cblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVsZW1lbnQoY29udGVudCwgbWV0YSwgYXR0cmlidXRlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50KTtcblxuICAgIC8vIExhenkgbG9hZCB0aGlzLm1ldGEgYW5kIHRoaXMuYXR0cmlidXRlcyBiZWNhdXNlIGl0J3MgYSBNaW5pbSBlbGVtZW50XG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSBnZXQgaW50byBjaXJjdWx1YXIgY2FsbHNcbiAgICBpZiAobWV0YSkge1xuICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEZyZWV6ZXMgdGhlIGVsZW1lbnQgdG8gcHJldmVudCBhbnkgbXV0YXRpb24uXG4gICAqIEEgZnJvemVuIGVsZW1lbnQgd2lsbCBhZGQgYHBhcmVudGAgcHJvcGVydHkgdG8gZXZlcnkgY2hpbGQgZWxlbWVudFxuICAgKiB0byBhbGxvdyB0cmF2ZXJzaW5nIHVwIHRoZSBlbGVtZW50IHRyZWUuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVsZW1lbnQsIFt7XG4gICAga2V5OiAnZnJlZXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbih0aGlzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9tZXRhKSB7XG4gICAgICAgIHRoaXMubWV0YS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLm1ldGEuZnJlZXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuZnJlZXplKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IF90aGlzO1xuICAgICAgICBlbGVtZW50LmZyZWV6ZSgpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheSh0aGlzLmNvbnRlbnQpKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcy5jb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcmltaXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmltaXRpdmUoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nsb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cbiAgICAgIGNvcHkuZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgaWYgKHRoaXMubWV0YS5sZW5ndGgpIHtcbiAgICAgICAgY29weS5fbWV0YSA9IHRoaXMubWV0YS5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBjb3B5Ll9hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmNsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5jbG9uZSkge1xuICAgICAgICAgIGNvcHkuY29udGVudCA9IHRoaXMuY29udGVudC5jbG9uZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250ZW50KSkge1xuICAgICAgICAgIGNvcHkuY29udGVudCA9IHRoaXMuY29udGVudC5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weS5jb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5LmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9WYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudG9WYWx1ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb250ZW50IGluc3RhbmNlb2YgS2V5VmFsdWVQYWlyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5OiB0aGlzLmNvbnRlbnQua2V5LnRvVmFsdWUoKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5jb250ZW50LnZhbHVlLnRvVmFsdWUoKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb250ZW50ICYmIHRoaXMuY29udGVudC5tYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC50b1ZhbHVlKCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWZlcmVuY2UgcG9pbnRpbmcgYXQgdGhlIEVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7UmVmRWxlbWVudH1cbiAgICAgKiBAbWVtYmVyb2YgRWxlbWVudC5wcm90b3R5cGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9SZWYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1JlZihwYXRoKSB7XG4gICAgICBpZiAodGhpcy5pZC50b1ZhbHVlKCkgPT09ICcnKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY3JlYXRlIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50IHRoYXQgZG9lcyBub3QgY29udGFpbiBhbiBJRCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gbmV3IHRoaXMuUmVmRWxlbWVudCh0aGlzLmlkLnRvVmFsdWUoKSk7XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHJlZi5wYXRoID0gcGF0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZ2l2ZW4gZWxlbWVudHMgaW4gdGhlIGVsZW1lbnQgdHJlZS5cbiAgICAgKiBXaGVuIHByb3ZpZGluZyBtdWx0aXBsZSBlbGVtZW50IG5hbWVzLCB5b3UgbXVzdCBmaXJzdCBmcmVlemUgdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXMgey4uLmVsZW1lbnROYW1lc31cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlTbGljZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZFJlY3Vyc2l2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRSZWN1cnNpdmUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZWxlbWVudE5hbWVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGVsZW1lbnROYW1lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmICF0aGlzLmlzRnJvemVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgcmVjdXJzaXZlIHdpdGggbXVsdGlwbGUgZWxlbWVudCBuYW1lcyB3aXRob3V0IGZpcnN0IGZyZWV6aW5nIHRoZSBlbGVtZW50LiBDYWxsIGBlbGVtZW50LmZyZWV6ZSgpYCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZXMucG9wKCk7XG4gICAgICB2YXIgZWxlbWVudHMgPSBuZXcgQXJyYXlTbGljZSgpO1xuXG4gICAgICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGFycmF5LCBlbGVtZW50KSB7XG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENoZWNrcyB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgYXBwZW5kcyBlbGVtZW50L3N1Yi1lbGVtZW50c1xuICAgICAgLy8gdGhhdCBtYXRjaCBlbGVtZW50IG5hbWUgdG8gZ2l2ZW4gYXJyYXlcbiAgICAgIHZhciBjaGVja0VsZW1lbnQgPSBmdW5jdGlvbiBjaGVja0VsZW1lbnQoYXJyYXksIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxlbWVudCA9PT0gZWxlbWVudE5hbWUpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1zID0gZWxlbWVudC5maW5kUmVjdXJzaXZlKGVsZW1lbnROYW1lKTtcbiAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgaXRlbXMucmVkdWNlKGFwcGVuZCwgYXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuY29udGVudCBpbnN0YW5jZW9mIEtleVZhbHVlUGFpcikge1xuICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRlbnQua2V5KSB7XG4gICAgICAgICAgICBjaGVja0VsZW1lbnQoYXJyYXksIGVsZW1lbnQuY29udGVudC5rZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIGNoZWNrRWxlbWVudChhcnJheSwgZWxlbWVudC5jb250ZW50LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgIC8vIERpcmVjdCBFbGVtZW50XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuZWxlbWVudCkge1xuICAgICAgICAgIGNoZWNrRWxlbWVudChlbGVtZW50cywgdGhpcy5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVsZW1lbnQgQXJyYXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250ZW50KSkge1xuICAgICAgICAgIHRoaXMuY29udGVudC5yZWR1Y2UoY2hlY2tFbGVtZW50LCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50TmFtZXMuaXNFbXB0eSkge1xuICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBwYXJlbnRFbGVtZW50cyA9IGVsZW1lbnQucGFyZW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmVsZW1lbnQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgICBmb3IgKHZhciBuYW1lc0luZGV4IGluIGVsZW1lbnROYW1lcykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50TmFtZXNbbmFtZXNJbmRleF07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJlbnRFbGVtZW50cy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHBhcmVudEVsZW1lbnRzID0gcGFyZW50RWxlbWVudHMuc3BsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoY29udGVudCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VxdWFscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzRXF1YWwodGhpcy50b1ZhbHVlKCksIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNZXRhUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRhUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5tZXRhLmhhc0tleShuYW1lKSkge1xuICAgICAgICBpZiAodGhpcy5pc0Zyb3plbikge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5yZWZyYWN0KHZhbHVlKTtcbiAgICAgICAgICBlbGVtZW50LmZyZWV6ZSgpO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXRhLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1ldGEuZ2V0KG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldE1ldGFQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1ldGFQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5tZXRhLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VsZW1lbnQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gUmV0dXJucyAnZWxlbWVudCcgc28gd2UgZG9uJ3QgaGF2ZSB1bmRlZmluZWQgYXMgZWxlbWVudFxuICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlZEVsZW1lbnQgfHwgJ2VsZW1lbnQnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc3RvcmVkRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29udGVudCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlTbGljZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnbnVsbCcgfHwgdmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFByaW1pdGl2ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy5fY29udGVudCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEtleVZhbHVlUGFpcikge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSB2YWx1ZS5tYXAodGhpcy5yZWZyYWN0KTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBuZXcgX3RoaXMyLk1lbWJlckVsZW1lbnQoa2V5LCB2YWx1ZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgY29udGVudCB0byBnaXZlbiB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE9iamVjdEVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWV0YScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX21ldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGcm96ZW4pIHtcbiAgICAgICAgICB2YXIgbWV0YSA9IG5ldyB0aGlzLk9iamVjdEVsZW1lbnQoKTtcbiAgICAgICAgICBtZXRhLmZyZWV6ZSgpO1xuICAgICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWV0YSA9IG5ldyB0aGlzLk9iamVjdEVsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX21ldGE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5PYmplY3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX21ldGEgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWV0YS5zZXQodmFsdWUgfHwge30pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhdHRyaWJ1dGVzIHByb3BlcnR5IGRlZmluZXMgYXR0cmlidXRlcyBhYm91dCB0aGUgZ2l2ZW4gaW5zdGFuY2VcbiAgICAgKiBvZiB0aGUgZWxlbWVudCwgYXMgc3BlY2lmaWVkIGJ5IHRoZSBlbGVtZW50IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHR5cGUgT2JqZWN0RWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdHRyaWJ1dGVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5fYXR0cmlidXRlcykge1xuICAgICAgICBpZiAodGhpcy5pc0Zyb3plbikge1xuICAgICAgICAgIHZhciBtZXRhID0gbmV3IHRoaXMuT2JqZWN0RWxlbWVudCgpO1xuICAgICAgICAgIG1ldGEuZnJlZXplKCk7XG4gICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzID0gbmV3IHRoaXMuT2JqZWN0RWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlcztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzLk9iamVjdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnNldCh2YWx1ZSB8fCB7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIElkZW50aWZpZXIsIE1VU1QgYmUgdW5pcXVlIHRocm91Z2hvdXQgYW4gZW50aXJlIGVsZW1lbnQgdHJlZS5cbiAgICAgKiBAdHlwZSBTdHJpbmdFbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1ldGFQcm9wZXJ0eSgnaWQnLCAnJyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtZW50KSB7XG4gICAgICB0aGlzLnNldE1ldGFQcm9wZXJ0eSgnaWQnLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBBcnJheUVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xhc3NlcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNZXRhUHJvcGVydHkoJ2NsYXNzZXMnLCBbXSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtZW50KSB7XG4gICAgICB0aGlzLnNldE1ldGFQcm9wZXJ0eSgnY2xhc3NlcycsIGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEh1bWFuLXJlYWRhYmxlIHRpdGxlIG9mIGVsZW1lbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdFbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RpdGxlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1ldGFQcm9wZXJ0eSgndGl0bGUnLCAnJyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtZW50KSB7XG4gICAgICB0aGlzLnNldE1ldGFQcm9wZXJ0eSgndGl0bGUnLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIdW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiBlbGVtZW50XG4gICAgICogQHR5cGUgU3RyaW5nRWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXNjcmlwdGlvbicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNZXRhUHJvcGVydHkoJ2Rlc2NyaXB0aW9uJywgJycpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZWxlbWVudCkge1xuICAgICAgdGhpcy5zZXRNZXRhUHJvcGVydHkoJ2Rlc2NyaXB0aW9uJywgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgQXJyYXlFbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2xpbmtzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1ldGFQcm9wZXJ0eSgnbGlua3MnLCBbXSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtZW50KSB7XG4gICAgICB0aGlzLnNldE1ldGFQcm9wZXJ0eSgnbGlua3MnLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZnJvemVuLlxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAc2VlIGZyZWV6ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc0Zyb3plbicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIG9mIHRoZSBwYXJlbnQgZWxlbWVudHMuXG4gICAgICogQHR5cGUgQXJyYXlTbGljZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXJlbnRzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgICAgdmFyIHBhcmVudHMgPSBuZXcgQXJyYXlTbGljZSgpO1xuXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBvZiB0aGUgY2hpbGRyZW4gZWxlbWVudHMgZm91bmQgd2l0aGluIHRoZSBlbGVtZW50LlxuICAgICAqIEB0eXBlIEFycmF5U2xpY2VcbiAgICAgKiBAc2VlIHJlY3Vyc2l2ZUNoaWxkcmVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoaWxkcmVuJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNsaWNlKHRoaXMuY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnRlbnQgaW5zdGFuY2VvZiBLZXlWYWx1ZVBhaXIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IEFycmF5U2xpY2UoW3RoaXMuY29udGVudC5rZXldKTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZW50LnZhbHVlKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNvbnRlbnQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2xpY2UoW3RoaXMuY29udGVudF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEFycmF5U2xpY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYWxsIG9mIHRoZSBjaGlsZHJlbiBlbGVtZW50cyBmb3VuZCB3aXRoaW4gdGhlIGVsZW1lbnQgcmVjdXJzaXZlbHkuXG4gICAgKiBAdHlwZSBBcnJheVNsaWNlXG4gICAgKiBAc2VlIGNoaWxkcmVuXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVjdXJzaXZlQ2hpbGRyZW4nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IEFycmF5U2xpY2UoKTtcblxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgZWxlbWVudC5yZWN1cnNpdmVDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVsZW1lbnQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEtleVZhbHVlUGFpciA9IHJlcXVpcmUoJy4uL0tleVZhbHVlUGFpcicpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL0VsZW1lbnQnKTtcblxuLyoqXG4gKiBAY2xhc3MgTWVtYmVyRWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0ga2V5XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHZhbHVlXG4gKiBAcGFyYW0gbWV0YVxuICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzKE1lbWJlckVsZW1lbnQsIF9FbGVtZW50KTtcblxuICBmdW5jdGlvbiBNZW1iZXJFbGVtZW50KGtleSwgdmFsdWUsIG1ldGEsIGF0dHJpYnV0ZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtYmVyRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTWVtYmVyRWxlbWVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1lbWJlckVsZW1lbnQpKS5jYWxsKHRoaXMsIG5ldyBLZXlWYWx1ZVBhaXIoKSwgbWV0YSwgYXR0cmlidXRlcykpO1xuXG4gICAgX3RoaXMuZWxlbWVudCA9ICdtZW1iZXInO1xuICAgIF90aGlzLmtleSA9IGtleTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSBFbGVtZW50XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1lbWJlckVsZW1lbnQsIFt7XG4gICAga2V5OiAna2V5JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQua2V5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5KSB7XG4gICAgICB0aGlzLmNvbnRlbnQua2V5ID0gdGhpcy5yZWZyYWN0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgRWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuY29udGVudC52YWx1ZSA9IHRoaXMucmVmcmFjdCh2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lbWJlckVsZW1lbnQ7XG59KEVsZW1lbnQpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xuXG4vKipcbiAqL1xuXG52YXIgTnVsbEVsZW1lbnQgPSBmdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzKE51bGxFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gTnVsbEVsZW1lbnQoY29udGVudCwgbWV0YSwgYXR0cmlidXRlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdWxsRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVsbEVsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdWxsRWxlbWVudCkpLmNhbGwodGhpcywgY29udGVudCB8fCBudWxsLCBtZXRhLCBhdHRyaWJ1dGVzKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50ID0gJ251bGwnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOdWxsRWxlbWVudCwgW3tcbiAgICBrZXk6ICdwcmltaXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmltaXRpdmUoKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgdGhlIHZhbHVlIG9mIG51bGwnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTnVsbEVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxFbGVtZW50OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xuXG4vKipcbiAqIEBjbGFzcyBOdW1iZXJFbGVtZW50XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRlbnRcbiAqIEBwYXJhbSBtZXRhXG4gKiBAcGFyYW0gYXR0cmlidXRlc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHMoTnVtYmVyRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIE51bWJlckVsZW1lbnQoY29udGVudCwgbWV0YSwgYXR0cmlidXRlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJFbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJFbGVtZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyRWxlbWVudCkpLmNhbGwodGhpcywgY29udGVudCwgbWV0YSwgYXR0cmlidXRlcykpO1xuXG4gICAgX3RoaXMuZWxlbWVudCA9ICdudW1iZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOdW1iZXJFbGVtZW50LCBbe1xuICAgIGtleTogJ3ByaW1pdGl2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW1pdGl2ZSgpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTnVtYmVyRWxlbWVudDtcbn0oRWxlbWVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBuZWdhdGUgPSByZXF1aXJlKCdsb2Rhc2gvbmVnYXRlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxudmFyIEFycmF5RWxlbWVudCA9IHJlcXVpcmUoJy4vQXJyYXlFbGVtZW50Jyk7XG52YXIgTWVtYmVyRWxlbWVudCA9IHJlcXVpcmUoJy4vTWVtYmVyRWxlbWVudCcpO1xudmFyIE9iamVjdFNsaWNlID0gcmVxdWlyZSgnLi4vT2JqZWN0U2xpY2UnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0gY29udGVudFxuICogQHBhcmFtIG1ldGFcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gKi9cblxudmFyIE9iamVjdEVsZW1lbnQgPSBmdW5jdGlvbiAoX0FycmF5RWxlbWVudCkge1xuICBfaW5oZXJpdHMoT2JqZWN0RWxlbWVudCwgX0FycmF5RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gT2JqZWN0RWxlbWVudChjb250ZW50LCBtZXRhLCBhdHRyaWJ1dGVzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdEVsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE9iamVjdEVsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3RFbGVtZW50KSkuY2FsbCh0aGlzLCBjb250ZW50IHx8IFtdLCBtZXRhLCBhdHRyaWJ1dGVzKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50ID0gJ29iamVjdCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9iamVjdEVsZW1lbnQsIFt7XG4gICAga2V5OiAncHJpbWl0aXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbWl0aXZlKCkge1xuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1ZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdHMsIGVsKSB7XG4gICAgICAgIHJlc3VsdHNbZWwua2V5LnRvVmFsdWUoKV0gPSBlbC52YWx1ZS50b1ZhbHVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHZhciBtZW1iZXIgPSB0aGlzLmdldE1lbWJlcihuYW1lKTtcblxuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICByZXR1cm4gbWVtYmVyLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TWVtYmVyRWxlbWVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWVtYmVyKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5maW5kKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmtleS50b1ZhbHVlKCkgPT09IG5hbWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IG51bGw7XG5cbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0ua2V5LnRvVmFsdWUoKSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJlbW92ZWQgPSBpdGVtO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0S2V5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0S2V5KG5hbWUpIHtcbiAgICAgIHZhciBtZW1iZXIgPSB0aGlzLmdldE1lbWJlcihuYW1lKTtcblxuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICByZXR1cm4gbWVtYmVyLmtleTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYWxsb3dzIGVpdGhlciBhIGtleS92YWx1ZSBwYWlyIHRvIGJlIGdpdmVuIG9yIGFuIG9iamVjdFxuICAgICAqIElmIGFuIG9iamVjdCBpcyBnaXZlbiwgZWFjaCBrZXkgaXMgc2V0IHRvIGl0cyByZXNwZWN0aXZlIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXlPck9iamVjdCwgdmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoa2V5T3JPYmplY3QpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGtleU9yT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3RLZXkpIHtcbiAgICAgICAgICBfdGhpczIuc2V0KG9iamVjdEtleSwga2V5T3JPYmplY3Rbb2JqZWN0S2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSBhcyBrZXkgZm9yIGNsYXJpdHlcbiAgICAgIHZhciBrZXkgPSBrZXlPck9iamVjdDtcbiAgICAgIHZhciBtZW1iZXIgPSB0aGlzLmdldE1lbWJlcihrZXkpO1xuXG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIG1lbWJlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2gobmV3IE1lbWJlckVsZW1lbnQoa2V5LCB2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAna2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5rZXkudG9WYWx1ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlLnRvVmFsdWUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNLZXkodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0ua2V5LmVxdWFscyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFtpdGVtLmtleS50b1ZhbHVlKCksIGl0ZW0udmFsdWUudG9WYWx1ZSgpXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYmluZCh0aGlzQXJnKShpdGVtLnZhbHVlLCBpdGVtLmtleSwgaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRydXRoeSByZXN1bHRzIG9mIGNhbGxpbmcgdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIHdpdGggZWFjaCBlbGVtZW50IG9mIHRoaXMgc2VxdWVuY2VcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQSBjbG9zdXJlIHRoYXQgYWNjZXB0cyB0aGUgdmFsdWUsIGtleSBhbmQgbWVtYmVyIGVsZW1lbnQgb2YgdGhpcyBvYmplY3QgYXMgaXRzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIG9wdGlvbmFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgbm9uLXVuZGVmaW5lZCByZXN1bHRzIG9mIGNhbGxpbmcgdHJhbnNmb3JtIHdpdGggZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYWN0TWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFjdE1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBtZW1iZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrLmJpbmQodGhpc0FyZykodmFsdWUsIGtleSwgbWVtYmVyKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIChpLmUgdGhlIHJlZmVyZW5jZSBPYmplY3QpIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0U2xpY2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RTbGljZSh0aGlzLmNvbnRlbnQpLmZpbHRlcihjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyAoaS5lIHRoZSByZWZlcmVuY2UgT2JqZWN0KSB3aGVuIGV4ZWN1dGluZyBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdFNsaWNlfVxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE9iamVjdEVsZW1lbnQucHJvdG90eXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlamVjdChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShjYWxsYmFjayksIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgKGkuZSB0aGUgcmVmZXJlbmNlIE9iamVjdCkgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBPYmplY3RFbGVtZW50LnByb3RvdHlwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3JFYWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKHRoaXNBcmcpKGl0ZW0udmFsdWUsIGl0ZW0ua2V5LCBpdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYmplY3RFbGVtZW50O1xufShBcnJheUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdEVsZW1lbnQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9FbGVtZW50Jyk7XG5cbi8qKlxuICogQGNsYXNzIFN0cmluZ0VsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIG1ldGFcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0cyhTdHJpbmdFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3RyaW5nRWxlbWVudChjb250ZW50LCBtZXRhLCBhdHRyaWJ1dGVzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ0VsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0cmluZ0VsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdFbGVtZW50KSkuY2FsbCh0aGlzLCBjb250ZW50LCBtZXRhLCBhdHRyaWJ1dGVzKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50ID0gJ3N0cmluZyc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmluZ0VsZW1lbnQsIFt7XG4gICAga2V5OiAncHJpbWl0aXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbWl0aXZlKCkge1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJpbmdFbGVtZW50O1xufShFbGVtZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSlNPTlNlcmlhbGlzZXIgPSByZXF1aXJlKCcuL0pTT05TZXJpYWxpc2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9KU09OU2VyaWFsaXNlcikge1xuICBfaW5oZXJpdHMoSlNPTjA2U2VyaWFsaXNlciwgX0pTT05TZXJpYWxpc2VyKTtcblxuICBmdW5jdGlvbiBKU09OMDZTZXJpYWxpc2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKU09OMDZTZXJpYWxpc2VyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSlNPTjA2U2VyaWFsaXNlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEpTT04wNlNlcmlhbGlzZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKU09OMDZTZXJpYWxpc2VyLCBbe1xuICAgIGtleTogJ3NlcmlhbGlzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGlzZShlbGVtZW50KSB7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gZWxlbWVudCBgJyArIGVsZW1lbnQgKyAnYCBpcyBub3QgYW4gRWxlbWVudCBpbnN0YW5jZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFyaWFibGUgPSB2b2lkIDA7XG4gICAgICBpZiAoZWxlbWVudC5fYXR0cmlidXRlcyAmJiBlbGVtZW50LmF0dHJpYnV0ZXMuZ2V0KCd2YXJpYWJsZScpKSB7XG4gICAgICAgIHZhcmlhYmxlID0gZWxlbWVudC5hdHRyaWJ1dGVzLmdldCgndmFyaWFibGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuZWxlbWVudFxuICAgICAgfTtcblxuICAgICAgaWYgKGVsZW1lbnQuX21ldGEgJiYgZWxlbWVudC5fbWV0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBheWxvYWQubWV0YSA9IHRoaXMuc2VyaWFsaXNlT2JqZWN0KGVsZW1lbnQubWV0YSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VudW0gPSBlbGVtZW50LmVsZW1lbnQgPT09ICdlbnVtJyB8fCBlbGVtZW50LmF0dHJpYnV0ZXMua2V5cygpLmluZGV4T2YoJ2VudW1lcmF0aW9ucycpICE9PSAtMTtcblxuICAgICAgaWYgKGlzRW51bSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuZW51bVNlcmlhbGlzZUF0dHJpYnV0ZXMoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBwYXlsb2FkLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuX2F0dHJpYnV0ZXMgJiYgZWxlbWVudC5fYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblxuICAgICAgICAvLyBNZXRhIGF0dHJpYnV0ZSB3YXMgcmVuYW1lZCB0byBtZXRhZGF0YVxuXG4gICAgICAgIGlmIChfYXR0cmlidXRlcy5nZXQoJ21ldGFkYXRhJykpIHtcbiAgICAgICAgICBfYXR0cmlidXRlcyA9IF9hdHRyaWJ1dGVzLmNsb25lKCk7XG4gICAgICAgICAgX2F0dHJpYnV0ZXMuc2V0KCdtZXRhJywgX2F0dHJpYnV0ZXMuZ2V0KCdtZXRhZGF0YScpKTtcbiAgICAgICAgICBfYXR0cmlidXRlcy5yZW1vdmUoJ21ldGFkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudC5lbGVtZW50ID09PSAnbWVtYmVyJyAmJiB2YXJpYWJsZSkge1xuICAgICAgICAgIF9hdHRyaWJ1dGVzID0gX2F0dHJpYnV0ZXMuY2xvbmUoKTtcbiAgICAgICAgICBfYXR0cmlidXRlcy5yZW1vdmUoJ3ZhcmlhYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2F0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBheWxvYWQuYXR0cmlidXRlcyA9IHRoaXMuc2VyaWFsaXNlT2JqZWN0KF9hdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNFbnVtKSB7XG4gICAgICAgIHBheWxvYWQuY29udGVudCA9IHRoaXMuZW51bVNlcmlhbGlzZUNvbnRlbnQoZWxlbWVudCwgcGF5bG9hZCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXNbZWxlbWVudC5lbGVtZW50ICsgJ1NlcmlhbGlzZUNvbnRlbnQnXSkge1xuICAgICAgICBwYXlsb2FkLmNvbnRlbnQgPSB0aGlzW2VsZW1lbnQuZWxlbWVudCArICdTZXJpYWxpc2VDb250ZW50J10oZWxlbWVudCwgcGF5bG9hZCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh2YXJpYWJsZSAmJiBlbGVtZW50LmNvbnRlbnQua2V5KSB7XG4gICAgICAgICAgY29udGVudCA9IGVsZW1lbnQuY29udGVudC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnRlbnQua2V5LmF0dHJpYnV0ZXMuc2V0KCd2YXJpYWJsZScsIHZhcmlhYmxlKTtcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy5zZXJpYWxpc2VDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnNlcmlhbGlzZUNvbnRlbnQoZWxlbWVudC5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNlcmlhbGlzZUNvbnRlbnQoZWxlbWVudCwgY29udGVudCkpIHtcbiAgICAgICAgICBwYXlsb2FkLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZFNlcmlhbGlzZUNvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRTZXJpYWxpc2VDb250ZW50KGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5lbGVtZW50ID09PSAncGFyc2VSZXN1bHQnIHx8IGVsZW1lbnQuZWxlbWVudCA9PT0gJ2h0dHBSZXF1ZXN0JyB8fCBlbGVtZW50LmVsZW1lbnQgPT09ICdodHRwUmVzcG9uc2UnIHx8IGVsZW1lbnQuZWxlbWVudCA9PT0gJ2NhdGVnb3J5JyB8fCBlbGVtZW50LmVsZW1lbnQgPT09ICdsaW5rJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWZTZXJpYWxpc2VDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmU2VyaWFsaXNlQ29udGVudChlbGVtZW50LCBwYXlsb2FkKSB7XG4gICAgICBkZWxldGUgcGF5bG9hZC5hdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiBlbGVtZW50LnRvVmFsdWUoKSxcbiAgICAgICAgcGF0aDogZWxlbWVudC5wYXRoLnRvVmFsdWUoKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzb3VyY2VNYXBTZXJpYWxpc2VDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlTWFwU2VyaWFsaXNlQ29udGVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50b1ZhbHVlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGF0YVN0cnVjdHVyZVNlcmlhbGlzZUNvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhU3RydWN0dXJlU2VyaWFsaXNlQ29udGVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gW3RoaXMuc2VyaWFsaXNlQ29udGVudChlbGVtZW50LmNvbnRlbnQpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbnVtU2VyaWFsaXNlQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudW1TZXJpYWxpc2VBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcy5jbG9uZSgpO1xuXG4gICAgICAvLyBFbnVtZXJhdGlvbnMgYXR0cmlidXRlIHdhcyBpcyBwbGFjZWQgaW5zaWRlIGNvbnRlbnQgKHNlZSBgZW51bVNlcmlhbGlzZUNvbnRlbnRgIGJlbG93KVxuICAgICAgdmFyIGVudW1lcmF0aW9ucyA9IGF0dHJpYnV0ZXMucmVtb3ZlKCdlbnVtZXJhdGlvbnMnKSB8fCBuZXcgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuQXJyYXkoW10pO1xuXG4gICAgICAvLyBSZW1vdmUgZml4ZWQgdHlwZSBhdHRyaWJ1dGUgZnJvbSBzYW1wbGVzIGFuZCBkZWZhdWx0XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXR0cmlidXRlcy5nZXQoJ2RlZmF1bHQnKTtcbiAgICAgIHZhciBzYW1wbGVzID0gYXR0cmlidXRlcy5nZXQoJ3NhbXBsZXMnKSB8fCBuZXcgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuQXJyYXkoW10pO1xuXG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICYmIGRlZmF1bHRWYWx1ZS5jb250ZW50KSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZS5jb250ZW50LmF0dHJpYnV0ZXMucmVtb3ZlKCd0eXBlQXR0cmlidXRlcycpO1xuICAgICAgICAvLyBXcmFwIGRlZmF1bHQgaW4gYXJyYXkgKG5vdCBzdXJlIGl0IGlzIHJlYWxseSBuZWVkZWQgYmVjYXVzZSB0ZXN0cyBwYXNzIHdpdGhvdXQgdGhpcyBsaW5lKVxuICAgICAgICBhdHRyaWJ1dGVzLnNldCgnZGVmYXVsdCcsIG5ldyB0aGlzLm5hbWVzcGFjZS5lbGVtZW50cy5BcnJheShbZGVmYXVsdFZhbHVlLmNvbnRlbnRdKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmlwIHR5cGVBdHRyaWJ1dGVzIGZyb20gc2FtcGxlcywgMC42IGRvZXNuJ3QgdXN1YWxseSBjb250YWluIHRoZW0gaW4gc2FtcGxlc1xuICAgICAgc2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgaWYgKHNhbXBsZS5jb250ZW50ICYmIHNhbXBsZS5jb250ZW50LmVsZW1lbnQpIHtcbiAgICAgICAgICBzYW1wbGUuY29udGVudC5hdHRyaWJ1dGVzLnJlbW92ZSgndHlwZUF0dHJpYnV0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENvbnRlbnQgLT4gU2FtcGxlc1xuICAgICAgaWYgKGVsZW1lbnQuY29udGVudCAmJiBlbnVtZXJhdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgZW51bWVyYXRpb25zLCBjb250ZW50IHNob3VsZCBzdGF5IGluXG4gICAgICAgIC8vIGNvbnRlbnQgKGVudW1lcmF0aW9ucykgYXMgcGVyIERyYWZ0ZXIgMyBiZWhhdmlvdXIuXG4gICAgICAgIHNhbXBsZXMudW5zaGlmdChlbGVtZW50LmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICBzYW1wbGVzID0gc2FtcGxlcy5tYXAoZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgICBpZiAoc2FtcGxlIGluc3RhbmNlb2YgX3RoaXMyLm5hbWVzcGFjZS5lbGVtZW50cy5BcnJheSkge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgX3RoaXMyLm5hbWVzcGFjZS5lbGVtZW50cy5BcnJheShbc2FtcGxlLmNvbnRlbnRdKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cmlidXRlcy5zZXQoJ3NhbXBsZXMnLCBzYW1wbGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpc2VPYmplY3QoYXR0cmlidXRlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW51bVNlcmlhbGlzZUNvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnVtU2VyaWFsaXNlQ29udGVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gSW4gQVBJIEVsZW1lbnRzIDwgMS4wLCB0aGUgY29udGVudCBpcyB0aGUgZW51bWVyYXRpb25zXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIGVudW1lcmF0aW9ucywgdXNlIHRoZSB2YWx1ZSAoRHJhZnRlciAzIGJlaGF2aW91cilcblxuICAgICAgaWYgKGVsZW1lbnQuX2F0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGVudW1lcmF0aW9ucyA9IGVsZW1lbnQuYXR0cmlidXRlcy5nZXQoJ2VudW1lcmF0aW9ucycpO1xuXG4gICAgICAgIGlmIChlbnVtZXJhdGlvbnMgJiYgZW51bWVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gZW51bWVyYXRpb25zLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChlbnVtZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGUgPSBlbnVtZXJhdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgZS5hdHRyaWJ1dGVzLnJlbW92ZSgndHlwZUF0dHJpYnV0ZXMnKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuc2VyaWFsaXNlKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5jb250ZW50LmNsb25lKCk7XG4gICAgICAgIHZhbHVlLmF0dHJpYnV0ZXMucmVtb3ZlKCd0eXBlQXR0cmlidXRlcycpO1xuICAgICAgICByZXR1cm4gW3RoaXMuc2VyaWFsaXNlKHZhbHVlKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXNlcmlhbGlzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VyaWFsaXNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMubmFtZXNwYWNlLmVsZW1lbnRzLlN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuTnVtYmVyKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuQm9vbGVhbih2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMubmFtZXNwYWNlLmVsZW1lbnRzLk51bGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuQXJyYXkodmFsdWUubWFwKHRoaXMuZGVzZXJpYWxpc2UsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIEVsZW1lbnRDbGFzcyA9IHRoaXMubmFtZXNwYWNlLmdldEVsZW1lbnRDbGFzcyh2YWx1ZS5lbGVtZW50KTtcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnRDbGFzcygpO1xuXG4gICAgICBpZiAoZWxlbWVudC5lbGVtZW50ICE9PSB2YWx1ZS5lbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZWxlbWVudCA9IHZhbHVlLmVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5tZXRhKSB7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpc2VPYmplY3QodmFsdWUubWV0YSwgZWxlbWVudC5tZXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGlzZU9iamVjdCh2YWx1ZS5hdHRyaWJ1dGVzLCBlbGVtZW50LmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuZGVzZXJpYWxpc2VDb250ZW50KHZhbHVlLmNvbnRlbnQpO1xuICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCB8fCBlbGVtZW50LmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZWxlbWVudCA9PT0gJ2VudW0nKSB7XG4gICAgICAgIC8vIEdyYWIgZW51bWVyYXRpb25zIGZyb20gY29udGVudFxuICAgICAgICBpZiAoZWxlbWVudC5jb250ZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnNldCgnZW51bWVyYXRpb25zJywgZWxlbWVudC5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVud3JhcCB0aGUgc2FtcGxlIHZhbHVlIChpbnNpZGUgZG91YmxlIGFycmF5KVxuICAgICAgICB2YXIgc2FtcGxlcyA9IGVsZW1lbnQuYXR0cmlidXRlcy5nZXQoJ3NhbXBsZXMnKTtcbiAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnJlbW92ZSgnc2FtcGxlcycpO1xuXG4gICAgICAgIGlmIChzYW1wbGVzKSB7XG4gICAgICAgICAgLy8gUmUtd3JhcCBzYW1wbGVzIGZyb20gYXJyYXkgb2YgYXJyYXkgdG8gYXJyYXkgb2YgZW51bSdzXG5cbiAgICAgICAgICB2YXIgZXhpc3RpbmdTYW1wbGVzID0gc2FtcGxlcztcblxuICAgICAgICAgIHNhbXBsZXMgPSBuZXcgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuQXJyYXkoKTtcbiAgICAgICAgICBleGlzdGluZ1NhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhpc3RpbmdTYW1wbGUpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nU2FtcGxlLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgICAgICAgICB2YXIgZW51bUVsZW1lbnQgPSBuZXcgRWxlbWVudENsYXNzKHNhbXBsZSk7XG4gICAgICAgICAgICAgIGVudW1FbGVtZW50LmVsZW1lbnQgPSBlbGVtZW50LmVsZW1lbnQ7XG4gICAgICAgICAgICAgIHNhbXBsZXMucHVzaChlbnVtRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBzYW1wbGUgPSBzYW1wbGVzLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiAoc2FtcGxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNvbnRlbnQgPSBzYW1wbGUuY29udGVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5jb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQuYXR0cmlidXRlcy5zZXQoJ3NhbXBsZXMnLCBzYW1wbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbndyYXAgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGVsZW1lbnQuYXR0cmlidXRlcy5nZXQoJ2RlZmF1bHQnKTtcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZS5nZXQoMCk7XG4gICAgICAgICAgdmFyIGRlZmF1bHRFbGVtZW50ID0gbmV3IEVsZW1lbnRDbGFzcyhkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgIGRlZmF1bHRFbGVtZW50LmVsZW1lbnQgPSBlbGVtZW50LmVsZW1lbnQ7XG4gICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnNldCgnZGVmYXVsdCcsIGRlZmF1bHRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmVsZW1lbnQgPT09ICdkYXRhU3RydWN0dXJlJyAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQuY29udGVudCkpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JGNvbnRlbnQgPSBfc2xpY2VkVG9BcnJheShlbGVtZW50LmNvbnRlbnQsIDEpO1xuXG4gICAgICAgIGVsZW1lbnQuY29udGVudCA9IF9lbGVtZW50JGNvbnRlbnRbMF07XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZWxlbWVudCA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAvLyBcIm1ldGFcIiBhdHRyaWJ1dGUgaGFzIGJlZW4gcmVuYW1lZCB0byBtZXRhZGF0YVxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBlbGVtZW50LmF0dHJpYnV0ZXMuZ2V0KCdtZXRhJyk7XG5cbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnNldCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnJlbW92ZSgnbWV0YScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZWxlbWVudCA9PT0gJ21lbWJlcicgJiYgZWxlbWVudC5rZXkgJiYgZWxlbWVudC5rZXkuX2F0dHJpYnV0ZXMgJiYgZWxlbWVudC5rZXkuX2F0dHJpYnV0ZXMuZ2V0VmFsdWUoJ3ZhcmlhYmxlJykpIHtcbiAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnNldCgndmFyaWFibGUnLCBlbGVtZW50LmtleS5hdHRyaWJ1dGVzLmdldCgndmFyaWFibGUnKSk7XG4gICAgICAgIGVsZW1lbnQua2V5LmF0dHJpYnV0ZXMucmVtb3ZlKCd2YXJpYWJsZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlIEFQSVxuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXJpYWxpc2VDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXNlQ29udGVudChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIHRoaXMubmFtZXNwYWNlLmVsZW1lbnRzLkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXNlKGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIHRoaXMubmFtZXNwYWNlLktleVZhbHVlUGFpcikge1xuICAgICAgICB2YXIgcGFpciA9IHtcbiAgICAgICAgICBrZXk6IHRoaXMuc2VyaWFsaXNlKGNvbnRlbnQua2V5KVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb250ZW50LnZhbHVlKSB7XG4gICAgICAgICAgcGFpci52YWx1ZSA9IHRoaXMuc2VyaWFsaXNlKGNvbnRlbnQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50ICYmIGNvbnRlbnQubWFwKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50Lm1hcCh0aGlzLnNlcmlhbGlzZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc2VyaWFsaXNlQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VyaWFsaXNlQ29udGVudChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudC5lbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpc2UoY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGVudC5rZXkpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IG5ldyB0aGlzLm5hbWVzcGFjZS5LZXlWYWx1ZVBhaXIodGhpcy5kZXNlcmlhbGlzZShjb250ZW50LmtleSkpO1xuXG4gICAgICAgICAgaWYgKGNvbnRlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHBhaXIudmFsdWUgPSB0aGlzLmRlc2VyaWFsaXNlKGNvbnRlbnQudmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRlbnQubWFwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQubWFwKHRoaXMuZGVzZXJpYWxpc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZFJlZnJhY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRSZWZyYWN0KGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50Ll9hdHRyaWJ1dGVzICYmIGVsZW1lbnQuYXR0cmlidXRlcy5rZXlzKCkubGVuZ3RoIHx8IGVsZW1lbnQuX21ldGEgJiYgZWxlbWVudC5tZXRhLmtleXMoKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmVsZW1lbnQgPT09ICdlbnVtJykge1xuICAgICAgICAvLyBlbnVtIGVsZW1lbnRzIGFyZSB0cmVhdGVkIGxpa2UgcHJpbWl0aXZlcyAoYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZWxlbWVudCAhPT0gZWxlbWVudC5wcmltaXRpdmUoKSB8fCBlbGVtZW50LmVsZW1lbnQgPT09ICdtZW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29udmVydEtleVRvUmVmcmFjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRLZXlUb1JlZnJhY3Qoa2V5LCBpdGVtKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc2hvdWxkUmVmcmFjdChpdGVtKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpc2UoaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLmVsZW1lbnQgPT09ICdlbnVtJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpc2VFbnVtKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbS5lbGVtZW50ID09PSAnYXJyYXknKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBwbGFpbiBhcnJheSwgYnV0IG1heWJlIGl0IGNvbnRhaW5zIGVsZW1lbnRzIHdpdGhcbiAgICAgICAgLy8gYWRkaXRpb25hbCBpbmZvcm1hdGlvbj8gTGV0J3Mgc2VlIVxuICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW0ubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgdmFyIHN1Ykl0ZW0gPSBpdGVtLmdldChpbmRleCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zaG91bGRSZWZyYWN0KHN1Ykl0ZW0pIHx8IGtleSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnNlcmlhbGlzZShzdWJJdGVtKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdWJJdGVtLmVsZW1lbnQgPT09ICdhcnJheScgfHwgc3ViSXRlbS5lbGVtZW50ID09PSAnb2JqZWN0JyB8fCBzdWJJdGVtLmVsZW1lbnQgPT09ICdlbnVtJykge1xuICAgICAgICAgICAgLy8gaXRlbXMgZm9yIGFycmF5IG9yIGVudW0gaW5zaWRlIGFycmF5IGFyZSBhbHdheXMgc2VyaWFsaXNlZFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3ViSXRlbS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKHN1YlN1Ykl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5zZXJpYWxpc2Uoc3ViU3ViSXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goc3ViSXRlbS50b1ZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLmVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gb2JqZWN0LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgbWVtYmVycyBjb250YWluXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAgICAgICAgdmFyIF92YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBpdGVtLmNvbnRlbnQgfHwgW107XG5cbiAgICAgICAgZm9yICh2YXIgX2luZGV4ID0gMDsgX2luZGV4IDwgY29udGVudC5sZW5ndGg7IF9pbmRleCArPSAxKSB7XG4gICAgICAgICAgX3ZhbHVlcy5wdXNoKHRoaXMuc2VyaWFsaXNlKGNvbnRlbnRbX2luZGV4XSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF92YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtLnRvVmFsdWUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXJpYWxpc2VFbnVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXNlRW51bShlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuc2VyaWFsaXNlKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VyaWFsaXNlT2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXNlT2JqZWN0KG9iaikge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgb2JqLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqLmdldChrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gX3RoaXM2LmNvbnZlcnRLZXlUb1JlZnJhY3Qoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc2VyaWFsaXNlT2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpc2VPYmplY3QoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyhmcm9tKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdG8uc2V0KGtleSwgX3RoaXM3LmRlc2VyaWFsaXNlKGZyb21ba2V5XSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT04wNlNlcmlhbGlzZXI7XG59KEpTT05TZXJpYWxpc2VyKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQGNsYXNzIEpTT05TZXJpYWxpc2VyXG4gKlxuICogQHBhcmFtIHtOYW1lc3BhY2V9IG5hbWVzcGFjZVxuICpcbiAqIEBwcm9wZXJ0eSB7TmFtZXNwYWNlfSBuYW1lc3BhY2VcbiAqL1xudmFyIEpTT05TZXJpYWxpc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKU09OU2VyaWFsaXNlcihuYW1lc3BhY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlNlcmlhbGlzZXIpO1xuXG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2UgfHwgbmV3IHRoaXMuTmFtZXNwYWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05TZXJpYWxpc2VyLCBbe1xuICAgIGtleTogJ3NlcmlhbGlzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGlzZShlbGVtZW50KSB7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgdGhpcy5uYW1lc3BhY2UuZWxlbWVudHMuRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gZWxlbWVudCBgJyArIGVsZW1lbnQgKyAnYCBpcyBub3QgYW4gRWxlbWVudCBpbnN0YW5jZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudC5lbGVtZW50XG4gICAgICB9O1xuXG4gICAgICBpZiAoZWxlbWVudC5fbWV0YSAmJiBlbGVtZW50Ll9tZXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGF5bG9hZC5tZXRhID0gdGhpcy5zZXJpYWxpc2VPYmplY3QoZWxlbWVudC5tZXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuX2F0dHJpYnV0ZXMgJiYgZWxlbWVudC5fYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBheWxvYWQuYXR0cmlidXRlcyA9IHRoaXMuc2VyaWFsaXNlT2JqZWN0KGVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5zZXJpYWxpc2VDb250ZW50KGVsZW1lbnQuY29udGVudCk7XG5cbiAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGF5bG9hZC5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rlc2VyaWFsaXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpc2UodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUuZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QgY29udGFpbmluZyBhbiBlbGVtZW50IG5hbWUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIEVsZW1lbnRDbGFzcyA9IHRoaXMubmFtZXNwYWNlLmdldEVsZW1lbnRDbGFzcyh2YWx1ZS5lbGVtZW50KTtcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnRDbGFzcygpO1xuXG4gICAgICBpZiAoZWxlbWVudC5lbGVtZW50ICE9PSB2YWx1ZS5lbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZWxlbWVudCA9IHZhbHVlLmVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5tZXRhKSB7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpc2VPYmplY3QodmFsdWUubWV0YSwgZWxlbWVudC5tZXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGlzZU9iamVjdCh2YWx1ZS5hdHRyaWJ1dGVzLCBlbGVtZW50LmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuZGVzZXJpYWxpc2VDb250ZW50KHZhbHVlLmNvbnRlbnQpO1xuICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCB8fCBlbGVtZW50LmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZSBBUElcblxuICB9LCB7XG4gICAga2V5OiAnc2VyaWFsaXNlQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGlzZUNvbnRlbnQoY29udGVudCkge1xuICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiB0aGlzLm5hbWVzcGFjZS5lbGVtZW50cy5FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGlzZShjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiB0aGlzLm5hbWVzcGFjZS5LZXlWYWx1ZVBhaXIpIHtcbiAgICAgICAgdmFyIHBhaXIgPSB7XG4gICAgICAgICAga2V5OiB0aGlzLnNlcmlhbGlzZShjb250ZW50LmtleSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29udGVudC52YWx1ZSkge1xuICAgICAgICAgIHBhaXIudmFsdWUgPSB0aGlzLnNlcmlhbGlzZShjb250ZW50LnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudCAmJiBjb250ZW50Lm1hcCkge1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQubWFwKHRoaXMuc2VyaWFsaXNlLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzZXJpYWxpc2VDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50LmVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGlzZShjb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZW50LmtleSkge1xuICAgICAgICAgIHZhciBwYWlyID0gbmV3IHRoaXMubmFtZXNwYWNlLktleVZhbHVlUGFpcih0aGlzLmRlc2VyaWFsaXNlKGNvbnRlbnQua2V5KSk7XG5cbiAgICAgICAgICBpZiAoY29udGVudC52YWx1ZSkge1xuICAgICAgICAgICAgcGFpci52YWx1ZSA9IHRoaXMuZGVzZXJpYWxpc2UoY29udGVudC52YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGVudC5tYXApIHtcbiAgICAgICAgICByZXR1cm4gY29udGVudC5tYXAodGhpcy5kZXNlcmlhbGlzZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VyaWFsaXNlT2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXNlT2JqZWN0KG9iaikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICBvYmoua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmouZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBfdGhpcy5zZXJpYWxpc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXNlcmlhbGlzZU9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VyaWFsaXNlT2JqZWN0KGZyb20sIHRvKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgT2JqZWN0LmtleXMoZnJvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvLnNldChrZXksIF90aGlzMi5kZXNlcmlhbGlzZShmcm9tW2tleV0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09OU2VyaWFsaXNlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OU2VyaWFsaXNlcjsiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVsbChudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVsbCh2b2lkIDApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc051bGw7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwiLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9XG4gKlxuICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAqIC8vID0+IFsxLCAzLCA1XVxuICovXG5mdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIl19
